<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title id="page-title">Linha do Tempo Histórica</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <style>
    :root {
      --primary-color: #2196f3;
      --primary-dark: #1565C0;
      --error-color: #f44336;
      --bg-color: #f0f2f5;
      --text-color: #333;
      --card-bg: #fff;
      --border-color: #ddd;
      --shadow-color: rgba(0,0,0,0.1);
      --banner-text: white;
      --scrollbar-track: #ddd;
      --scrollbar-thumb: #2196f3;
      --grid-line-color: rgba(0,0,0,0.05);
    }

    .dark {
      --primary-color: #4676E0;
      --primary-dark: #3060C0;
      --error-color: #f44336;
      --bg-color: #121212;
      --text-color: #e0e0e0;
      --card-bg: #242424;
      --border-color: #444;
      --shadow-color: rgba(0,0,0,0.3);
      --banner-text: #f0f0f0;
      --scrollbar-track: #333;
      --scrollbar-thumb: #4676E0;
      --grid-line-color: rgba(255,255,255,0.05);
    }

    .event-flag {
      z-index: 10;
      transition: top 0.3s cubic-bezier(0.4, 0, 0.2, 1), transform 0.2s ease;
    }

    .event-flag:hover,
    .event-flag:focus,
    .event-flag[data-is-being-dragged="true"] {
      will-change: top, transform;
    }

    .event-flag.locked {
      cursor: default;
    }

    .person-event {
      z-index: 5;
      transition: top 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .person-event:hover,
    .person-event:focus,
    .person-event[data-is-being-dragged="true"] {
      will-change: top;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    body {
      background-color: var(--bg-color);
      min-height: 100vh;
      padding: 2rem;
      color: var(--text-color);
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    /* Modal de seleção de idioma */
    .language-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      backdrop-filter: blur(5px);
    }

    .language-modal.hidden {
      display: none;
    }

    .language-selector {
      background: var(--card-bg);
      padding: 40px;
      border-radius: 15px;
      box-shadow: 0 10px 30px var(--shadow-color);
      text-align: center;
      max-width: 500px;
      width: 90%;
    }

    .language-selector h2 {
      margin-bottom: 30px;
      color: var(--primary-color);
      font-size: 24px;
    }

    .language-options {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 20px;
      margin-bottom: 30px;
    }

    .language-option {
      padding: 20px;
      border: 2px solid var(--border-color);
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      background: var(--bg-color);
    }

    .language-option:hover {
      border-color: var(--primary-color);
      transform: translateY(-5px);
      box-shadow: 0 5px 15px var(--shadow-color);
    }

    .language-option.selected {
      border-color: var(--primary-color);
      background: rgba(33, 150, 243, 0.1);
    }

    .language-flag {
      font-size: 48px;
      margin-bottom: 10px;
    }

    .language-name {
      font-weight: bold;
      margin-bottom: 5px;
    }

    .language-native {
      font-size: 12px;
      color: var(--text-color);
      opacity: 0.7;
    }

    .language-confirm {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 15px 30px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      transition: background-color 0.3s;
    }

    .language-confirm:hover {
      background: var(--primary-dark);
    }

    .timeline-container {
      width: 100%;
      height: 100vh;
      overflow-x: auto;
      overflow-y: hidden;
      padding: 40px 0;
      position: fixed;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      padding-bottom: 40px;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      cursor: grab;
      touch-action: pan-x pinch-zoom;
    }

    .timeline-container::-webkit-scrollbar {
      height: 8px;
      width: 0;
    }

    .timeline-container::-webkit-scrollbar-track {
      background: var(--scrollbar-track);
      border-radius: 4px;
    }

    .timeline-container::-webkit-scrollbar-thumb {
      background: var(--scrollbar-thumb);
      border-radius: 4px;
    }

    .timeline-container {
      scrollbar-width: thin;
      scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
    }

    .timeline-horizontal {
      position: absolute;
      bottom: 40px;
      width: 100%;
      min-width: 100%;
      padding: 20px;
      counter-reset: person-index;
      transform: translateY(0);
      transition: width 0.3s ease;
    }

    .timeline-line {
      position: absolute;
      height: 6px;
      background-color: var(--primary-color);
      bottom: 50%;
      left: 0;
      right: 0;
      transform: translateY(50%);
      border-radius: 3px;
    }

    .center-marker-line {
      position: absolute;
      height: 20px;
      width: 4px;
      background: var(--primary-color);
      bottom: calc(50% - 10px);
      left: calc(((4499 - (-4500)) / 6600) * 100%);
      transform: translate(-50%, 0);
      z-index: 2;
    }

    .event {
      position: absolute;
      transform: translate(-50%, -50%);
      width: auto;
      cursor: pointer;
    }

    .event.top {
      top: -60px;
    }

    .event.bottom {
      top: 60px;
    }

    .event-content {
      display: none;
      background: var(--card-bg);
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 4px 8px var(--shadow-color);
      transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.2s ease;
      color: var(--text-color);
    }

    .event-content:hover,
    .event-content:focus {
      will-change: transform, opacity;
    }

    .event-flag-banner {
      display: none;
      font-size: 10px;
      padding: 2px 6px;
    }

    .event-flag:hover .event-flag-banner {
      display: block;
      background-color: var(--event-color);
      opacity: 0.8;
      color: var(--banner-text);
      white-space: nowrap;
      box-shadow: 0 2px 4px var(--shadow-color);
      position: relative;
      z-index: 15;
    }

    .event-flag:hover .event-content,
    .event-flag:focus .event-content {
      display: block;
      animation: fadeInUp 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .person-event:hover .event-content,
    .person-event:focus .event-content {
      display: block;
      animation: fadeInUp 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .event-flag {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      top: -240px;
      cursor: pointer;
    }

    .event-flag-line {
      width: 2px;
      background-color: var(--event-color);
      opacity: 0.7;
      height: 200px;
      position: absolute;
      top: 100%;
    }

    .event-flag-line::before {
      content: attr(data-year);
      position: absolute;
      top: -25px;
      left: 50%;
      transform: translateX(-50%);
      width: 40px;
      height: 40px;
      background-color: var(--event-color);
      border-radius: 50%;
      opacity: 0.9;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--banner-text);
      font-size: 11px;
      white-space: nowrap;
      z-index: 3;
      padding: 2px;
      text-align: center;
      line-height: 1;
      min-width: 40px;
      box-sizing: border-box;
    }

    .action-buttons {
      position: fixed;
      top: 70px;
      right: 20px;
      display: flex;
      flex-direction: row;
      gap: 10px;
      z-index: 998;
    }

    .zoom-control-horizontal {
      position: fixed;
      top: 20px;
      right: 20px;
      background: white;
      padding: 8px 12px;
      border-radius: 8px;
      box-shadow: 0 2px 8px var(--shadow-color);
      display: flex;
      align-items: center;
      gap: 10px;
      z-index: 998;
      color: #333;
      width: 240px;
      height: 40px;
      border: 1px solid var(--border-color);
    }
    
    .zoom-icon {
      display: none;
      position: fixed;
      top: 80px;
      right: 20px;
      width: 40px;
      height: 40px;
      border-radius: 8px;
      background: var(--primary-color);
      color: white;
      cursor: pointer;
      z-index: 998;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px var(--shadow-color);
    }

    .search-container {
      position: fixed;
      top: 20px;
      right: 270px;
      display: block;
      z-index: 1000;
      width: 240px;
    }

    .search-wrapper {
      position: relative;
      width: 100%;
      height: 40px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px var(--shadow-color);
      border: 1px solid var(--border-color);
      display: flex;
      overflow: hidden;
    }
    
    .search-icon {
      display: none;
      position: fixed;
      top: 140px;
      right: 20px;
      width: 40px;
      height: 40px;
      border-radius: 8px;
      background: var(--primary-color);
      color: white;
      cursor: pointer;
      z-index: 998;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px var(--shadow-color);
    }

    .add-btn {
      width: 40px;
      height: 40px;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      border-radius: 8px;
      transition: transform 0.3s ease;
    }

    .add-btn:hover {
      transform: scale(1.1);
      transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .add-btn:active {
      transform: scale(0.95);
    }

    .add-btn svg {
      width: 20px;
      height: 20px;
    }

    .add-person-btn {
      background: var(--primary-dark);
      color: white;
    }

    .add-event-btn {
      background: var(--primary-color);
      color: white;
    }

    .add-period-btn {
      background: var(--primary-dark);
      color: white;
    }

    .dark-mode-btn {
      background: #9013FE;
      color: white;
    }

    .stats-btn {
      background: #FF9800;
      color: white;
    }

    .keyboard-btn {
      background: #009688;
      color: white;
    }

    .help-btn {
      background: #607D8B;
      color: white;
    }

    .load-btn {
      background: #4CAF50;
      color: white;
    }

    .save-btn {
      background: var(--primary-color);
      color: white;
    }

    .pdf-btn {
      background: #E53935;
      color: white;
    }

    .clear-btn {
      background: var(--error-color);
      color: white;
    }
    
    .settings-btn, .settings-main-btn {
      background: #673AB7;
      color: white;
    }

    .language-btn {
      background: #4CAF50;
      color: white;
    }

    .test-img-btn {
      background: #FF9800;
      color: white;
    }

    .lock-all-btn {
      background: var(--primary-dark);
      color: white;
    }

    .event-form {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--card-bg);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 16px var(--shadow-color);
      z-index: 1000;
      color: var(--text-color);
      max-width: 90%;
      width: 500px;
      max-height: 85vh;
      overflow-y: auto;
    }

    .event-form.active {
      display: block;
    }

    .overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 999;
    }

    .overlay.active {
      display: block;
    }

    .form-group {
      margin-bottom: 15px;
    }

    .form-group label {
      display: block;
      margin-bottom: 5px;
    }

    .form-group input,
    .form-group textarea,
    .form-group select {
      width: 100%;
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background-color: var(--card-bg);
      color: var(--text-color);
    }

    .form-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .form-save-btn {
      background: var(--primary-color);
      color: white;
    }

    .form-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .cancel-btn {
      background: var(--border-color);
      color: var(--text-color);
    }

    .date-markers {
      position: absolute;
      bottom: -45px;
      left: 0;
      right: 0;
      height: 45px;
      display: flex;
      justify-content: space-between;
      color: var(--text-color);
    }

    .date-marker {
      display: flex;
      flex-direction: column;
      align-items: center;
      position: absolute;
      transform: translateX(-50%);
      min-width: 40px;
      text-align: center;
    }

    .date-marker span {
      position: relative;
      top: 15px;
      font-size: 11px;
      white-space: nowrap;
      padding: 2px 4px;
      background: var(--bg-color);
      border-radius: 3px;
      border: 1px solid var(--border-color);
      box-shadow: 0 1px 3px var(--shadow-color);
    }

    .date-marker::before {
      content: '';
      width: 2px;
      height: 20px;
      background-color: var(--text-color);
      margin-bottom: 0;
      position: absolute;
      top: -10px;
    }

    .minor-tick {
      position: absolute;
      transform: translateX(-50%);
    }

    .minor-tick::before {
      content: '';
      width: 1px;
      height: 10px;
      background-color: var(--text-color);
      margin-bottom: 0;
      position: absolute;
      top: -5px;
      opacity: 0.5;
    }

    .zoom-control-horizontal .zoom-label {
      display: none;
    }
    
    .zoom-control-horizontal .zoom-slider {
      flex: 1;
      height: 6px;
      -webkit-appearance: none;
      background: var(--border-color);
      border-radius: 5px;
      outline: none;
      transition: all 0.3s ease;
      accent-color: var(--primary-color);
    }
    
    .zoom-control-horizontal .zoom-percentage {
      font-size: 14px;
      font-weight: 600;
      color: #333;
      min-width: 45px;
      text-align: left;
      white-space: nowrap;
    }

    .zoom-control-horizontal .zoom-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      background: var(--primary-color);
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .zoom-control-horizontal .zoom-slider::-webkit-slider-thumb:hover {
      transform: scale(1.1);
      box-shadow: 0 2px 8px rgba(0,123,255,0.3);
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .zoom-control-horizontal .zoom-slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: var(--primary-color);
      border-radius: 50%;
      cursor: pointer;
      border: none;
      transition: all 0.2s ease;
    }

    .zoom-label {
      color: var(--text-color);
      font-size: 14px;
    }

    .life-span {
      position: absolute;
      height: 4px;
      background: var(--person-color);
      border-radius: 2px;
      top: 50%;
      transform: translateY(-50%);
      width: 100%;
      opacity: 0.8;
      left: 0;
    }

    .life-span.imprecise-start {
      background: linear-gradient(to right, transparent, var(--person-color));
    }

    .life-span.imprecise-end {
      background: linear-gradient(to right, var(--person-color), transparent);
    }

    .life-span.imprecise-both {
      background: linear-gradient(to right, transparent, var(--person-color), transparent);
    }

    .person-event {
      position: absolute;
      top: calc(-24px - (var(--person-row) * 24px));
      transform: none;
      cursor: pointer;
      width: auto;
      z-index: 5;
      transition: top 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      height: 24px;
      display: flex;
      align-items: center;
      min-width: 40px;
    }
    
    .person-event.locked {
      cursor: default;
    }

    .person-label {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--person-color);
      padding: 2px 8px;
      border-radius: 4px;
      color: var(--banner-text);
      font-size: 12px;
      white-space: nowrap;
      box-shadow: 0 1px 2px var(--shadow-color);
      line-height: 1.2;
      width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .person-event .event-content {
      display: none;
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 100%;
      margin-bottom: 10px;
      z-index: 20;
      background: var(--card-bg);
      padding: 10px 14px;
      border-radius: 8px;
      box-shadow: 0 4px 15px var(--shadow-color);
      min-width: 180px;
      max-width: 240px;
      border: 1px solid var(--border-color);
      font-size: 12px;
      line-height: 1.4;
    }

    .person-event:hover {
      z-index: 15;
    }

    .event-flag .event-content {
      display: none;
      position: absolute;
      left: 50%;
      top: -120px;
      transform: translateX(-50%);
      z-index: 20;
      background: var(--card-bg);
      padding: 8px 12px;
      border-radius: 8px;
      box-shadow: 0 4px 15px var(--shadow-color);
      min-width: 160px;
      max-width: 240px;
      font-size: 12px;
      line-height: 1.4;
      pointer-events: none;
      border: 1px solid var(--border-color);
    }

    .event-flag .event-content h3 {
      font-size: 13px;
      margin-bottom: 4px;
      color: var(--primary-color);
    }

    .event-flag .event-content h4 {
      font-size: 12px;
      margin: 0;
      font-weight: 600;
    }

    .event-flag .event-content p {
      font-size: 11px;
      margin: 4px 0 0 0;
    }

    .event-flag .event-content:after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-top: 8px solid var(--card-bg);
    }

    .person-event .event-content:after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-top: 8px solid var(--card-bg);
    }

    .person-event .event-content h4 {
      font-size: 12px;
      margin-bottom: 4px;
      font-weight: 600;
      color: var(--text-color);
    }

    .person-event .event-content p {
      font-size: 12px;
      margin: 2px 0;
      color: var(--text-color);
    }

    .context-menu {
      position: fixed;
      background: var(--card-bg);
      border-radius: 4px;
      box-shadow: 0 2px 5px var(--shadow-color);
      padding: 5px 0;
      min-width: 150px;
      z-index: 10000;
      display: none;
      color: var(--text-color);
    }

    .context-menu.active {
      display: block;
      animation: menuFadeIn 0.15s ease;
    }
    
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translate(-50%, 10px);
      }
      to {
        opacity: 1;
        transform: translate(-50%, 0);
      }
    }
    
    @keyframes menuFadeIn {
      from {
        opacity: 0;
        transform: scale(0.95);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .context-menu-item {
      padding: 8px 15px;
      cursor: pointer;
      font-size: 14px;
    }

    .context-menu-item:hover {
      background: var(--bg-color);
    }

    .context-menu-item.delete {
      color: var(--error-color);
    }
    
    .context-menu-item.toggle-lock {
      color: var(--primary-color);
    }

    .dropdown-content {
      display: none;
      position: absolute;
      top: 100%;
      right: 0;
      flex-direction: column;
      gap: 10px;
      margin-top: 10px;
      opacity: 0;
      transform: translateY(-10px);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    button.menu-btn {
      background: linear-gradient(45deg, var(--primary-color), var(--primary-dark));
      color: white;
      border: none;
      border-radius: 8px;
      padding: 10px;
      cursor: pointer;
      transition: background 0.3s;
    }

    .action-buttons.active .dropdown-content {
      display: flex;
      opacity: 1;
      transform: translateY(0);
    }

    /* Modal de Configurações */
    .settings-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.6);
      z-index: 10001;
      backdrop-filter: blur(8px);
      animation: fadeIn 0.3s ease;
    }

    .settings-modal.active {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .settings-window {
      background: var(--card-bg);
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      width: 90%;
      max-width: 600px;
      max-height: 80vh;
      overflow: hidden;
      animation: slideIn 0.4s ease;
      border: 1px solid var(--border-color);
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideIn {
      from { 
        opacity: 0;
        transform: scale(0.9) translateY(30px);
      }
      to { 
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }

    .settings-header {
      background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
      color: white;
      padding: 20px 30px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid var(--border-color);
    }

    .settings-title {
      font-size: 24px;
      font-weight: 600;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .settings-close {
      background: rgba(255,255,255,0.2);
      border: none;
      border-radius: 50%;
      width: 36px;
      height: 36px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.3s ease;
      color: white;
      font-size: 20px;
      font-weight: bold;
    }

    .settings-close:hover {
      background: rgba(255,255,255,0.3);
    }

    .settings-content {
      padding: 0;
      max-height: calc(80vh - 80px);
      overflow-y: auto;
    }

    .settings-section {
      padding: 25px 30px;
      border-bottom: 1px solid var(--border-color);
    }

    .settings-section:last-child {
      border-bottom: none;
    }

    .settings-section-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 15px;
      color: var(--primary-color);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .settings-option {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 15px 0;
      border-bottom: 1px solid rgba(0,0,0,0.05);
      transition: background 0.2s ease;
      cursor: pointer;
      border-radius: 8px;
      margin: 5px 0;
      padding: 15px;
    }

    .settings-option:hover {
      background: var(--bg-color);
    }

    .settings-option:last-child {
      border-bottom: none;
    }

    .settings-option-info {
      display: flex;
      align-items: center;
      gap: 15px;
      flex: 1;
    }

    .settings-option-icon {
      width: 24px;
      height: 24px;
      color: var(--primary-color);
    }

    .settings-option-text {
      display: flex;
      flex-direction: column;
    }

    .settings-option-title {
      font-weight: 600;
      color: var(--text-color);
      margin-bottom: 2px;
    }

    .settings-option-description {
      display: none;
    }

    .settings-toggle {
      width: 50px;
      height: 28px;
      background: var(--border-color);
      border-radius: 14px;
      position: relative;
      cursor: pointer;
      transition: background 0.3s ease;
      border: none;
    }

    .settings-toggle.active {
      background: var(--primary-color);
    }

    .settings-toggle::after {
      content: '';
      position: absolute;
      width: 24px;
      height: 24px;
      background: white;
      border-radius: 50%;
      top: 2px;
      left: 2px;
      transition: left 0.3s ease;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }

    .settings-toggle.active::after {
      left: 24px;
    }

    .settings-button {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 500;
      transition: background 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .settings-button:hover {
      background: var(--primary-dark);
    }

    .form-row {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }

    .form-row .form-group {
      flex: 1;
      margin-bottom: 0;
    }

    .period-overlay {
      position: absolute;
      top: -1000px;
      bottom: -1000px;
      background-color: var(--period-color);
      opacity: 0.05;
      pointer-events: auto;
      z-index: 1;
      transform: none !important;
      min-width: 10px;
    }

    .period-overlay:hover {
      opacity: 0.1;
    }

    .period-overlay:hover .event-content {
      display: block;
    }

    .period-overlay .event-content {
      display: none;
      position: absolute;
      left: 50%;
      bottom: 100%;
      margin-bottom: 10px;
      transform: translateX(-50%);
      z-index: 10;
      background: var(--card-bg);
      padding: 12px 16px;
      border-radius: 8px;
      box-shadow: 0 4px 15px var(--shadow-color);
      min-width: 200px;
      border: 1px solid var(--border-color);
    }

    .period-overlay .event-content:after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-top: 8px solid var(--card-bg);
    }

    .period-label {
      position: absolute;
      top: -30px;
      left: 0;
      transform: translateX(0);
      background: var(--period-color);
      color: var(--banner-text);
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      z-index: 2;
    }

    .checkbox-container {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    .checkbox-wrapper {
      display: flex;
      align-items: center;
      cursor: pointer;
    }

    .checkbox-wrapper input[type="checkbox"] {
      appearance: none;
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      border: 2px solid var(--primary-color);
      border-radius: 4px;
      outline: none;
      transition: all 0.3s;
      margin-right: 8px;
      position: relative;
      cursor: pointer;
      background-color: var(--card-bg);
    }

    .checkbox-wrapper input[type="checkbox"]:checked {
      background-color: var(--primary-color);
    }

    .checkbox-wrapper input[type="checkbox"]:checked::before {
      content: '✔';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 12px;
    }

    .checkbox-wrapper label {
      font-size: 14px;
      color: var(--text-color);
      user-select: none;
    }

    .period-overlay:hover {
      opacity: 0.1;
      z-index: 4;
    }

    .period-overlay:hover .event-content {
      display: block !important;
    }

    .period-top-bar {
      position: absolute;
      height: 18px;
      background: var(--period-color);
      border-radius: 3px;
      top: auto;
      opacity: 0.9;
      z-index: 10;
      box-shadow: 0 1px 3px var(--shadow-color);
      cursor: pointer;
      transition: top 0.3s cubic-bezier(0.4, 0, 0.2, 1), transform 0.2s ease, box-shadow 0.2s ease;
    }
    
    .period-top-bar:hover,
    .period-top-bar:focus,
    .period-top-bar[data-is-being-dragged="true"] {
      will-change: top, transform, box-shadow;
    }
    
    .period-top-bar:hover {
      box-shadow: 0 2px 8px var(--shadow-color);
      transform: translateY(-1px);
    }

    .period-top-bar.locked {
      cursor: default;
    }
    
    .search-input {
      flex: 1;
      padding: 8px 12px;
      border: none;
      background: transparent;
      font-size: 14px;
      color: var(--text-color);
      outline: none;
    }
    
    .search-button {
      background: var(--primary-color);
      color: white;
      border: none;
      width: 40px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 0 8px 8px 0;
    }
    
    .search-results {
      position: fixed;
      top: 120px;
      right: 20px;
      background: var(--card-bg);
      border-radius: 8px;
      padding: 10px;
      max-height: 300px;
      overflow-y: auto;
      width: 280px;
      box-shadow: 0 4px 8px var(--shadow-color);
      z-index: 997;
      display: none;
    }
    
    .search-results.active {
      display: block;
    }
    
    .search-result-item {
      padding: 8px;
      cursor: pointer;
      border-bottom: 1px solid var(--border-color);
    }
    
    .search-result-item:hover {
      background-color: var(--bg-color);
    }
    
    .search-result-title {
      font-weight: bold;
    }
    
    .search-result-year {
      font-size: 12px;
      color: var(--primary-color);
    }
    
    .toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 9999;
    }
    
    .toast {
      background: var(--card-bg);
      color: var(--text-color);
      border-left: 4px solid var(--primary-color);
      padding: 12px 20px;
      margin-top: 10px;
      border-radius: 4px;
      box-shadow: 0 4px 8px var(--shadow-color);
      animation: slideIn 0.3s, fadeOut 0.5s 2.5s forwards;
      max-width: 300px;
    }
    
    .toast.error {
      border-left-color: var(--error-color);
    }
    
    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }
    
    .highlighted {
      animation: highlight 2s ease;
    }
    
    @keyframes highlight {
      0% { filter: brightness(1); }
      50% { filter: brightness(1.5); }
      100% { filter: brightness(1); }
    }
    
    button:focus, input:focus, textarea:focus {
      outline: 2px solid var(--primary-color);
      outline-offset: 2px;
    }

    #form-error {
      color: var(--error-color);
      margin-top: 10px;
      display: none;
    }
    
    .modal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--card-bg);
      padding: 25px;
      border-radius: 8px;
      box-shadow: 0 4px 16px var(--shadow-color);
      z-index: 1001;
      color: var(--text-color);
      max-width: 90%;
      width: 600px;
      max-height: 85vh;
      overflow-y: auto;
    }
    
    .modal.active {
      display: block;
    }
    
    .modal-title {
      font-size: 20px;
      margin-bottom: 15px;
      color: var(--primary-color);
    }
    
    .close-modal {
      position: absolute;
      top: 15px;
      right: 15px;
      background: none;
      border: none;
      font-size: 20px;
      color: var(--text-color);
      cursor: pointer;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
    }
    
    .close-modal:hover {
      background: var(--bg-color);
    }
    
    .stats-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 20px;
    }
    
    .stat-card {
      background: var(--bg-color);
      border-radius: 8px;
      padding: 15px;
      flex: 1 1 calc(33% - 20px);
      min-width: 150px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    .stat-value {
      font-size: 28px;
      font-weight: bold;
      color: var(--primary-color);
    }
    
    .stat-label {
      font-size: 14px;
      color: var(--text-color);
      text-align: center;
    }
    
    .stat-chart {
      width: 100%;
      height: 200px;
      margin-top: 20px;
      background: var(--bg-color);
      border-radius: 8px;
      padding: 15px;
      position: relative;
    }
    
    .chart-bar {
      position: absolute;
      bottom: 40px;
      width: 30px;
      background: var(--primary-color);
      border-radius: 4px 4px 0 0;
      transition: height 0.5s ease;
    }
    
    .chart-label {
      position: absolute;
      bottom: 10px;
      text-align: center;
      font-size: 12px;
      color: var(--text-color);
      transform: translateX(-50%);
    }
    
    .keyboard-shortcut {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--border-color);
    }
    
    .shortcut-keys {
      display: flex;
      gap: 5px;
    }
    
    .key {
      background: var(--bg-color);
      padding: 3px 8px;
      border-radius: 4px;
      border: 1px solid var(--border-color);
      font-size: 12px;
      min-width: 25px;
      text-align: center;
    }
    
    .shortcut-description {
      color: var(--text-color);
    }
    
    .tutorial-step {
      margin-bottom: 20px;
    }
    
    .tutorial-step-number {
      display: inline-block;
      width: 24px;
      height: 24px;
      background: var(--primary-color);
      color: white;
      border-radius: 50%;
      text-align: center;
      margin-right: 10px;
      font-weight: bold;
    }
    
    .tutorial-step-title {
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 16px;
    }
    
    .tutorial-image {
      max-width: 100%;
      height: auto;
      margin: 10px 0;
      border-radius: 4px;
      border: 1px solid var(--border-color);
    }
    
    .tutorial-highlight {
      position: absolute;
      border: 2px dashed var(--primary-color);
      border-radius: 4px;
      pointer-events: none;
      z-index: 1000;
      animation: pulse 1.5s infinite;
    }
    

    .autocomplete-container {
      position: relative;
    }

    .autocomplete-suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 150px;
      overflow-y: auto;
      border: 1px solid var(--border-color);
      border-radius: 0 0 4px 4px;
      background: var(--card-bg);
      z-index: 10;
      box-shadow: 0 4px 8px var(--shadow-color);
      display: none;
    }

    .autocomplete-suggestions.active {
      display: block;
    }

    .autocomplete-suggestion {
      padding: 8px 10px;
      cursor: pointer;
      font-size: 14px;
      border-bottom: 1px solid var(--border-color);
    }

    .autocomplete-suggestion:hover,
    .autocomplete-suggestion.selected {
      background-color: var(--bg-color);
    }
    
    .search-autocomplete {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: 0 0 8px 8px;
      box-shadow: 0 4px 8px var(--shadow-color);
      z-index: 10002;
      max-height: 200px;
      overflow-y: auto;
      display: none;
      margin-top: 0;
    }
    
    .search-autocomplete.active {
      display: block;
    }
    
    .search-suggestion {
      padding: 8px 12px;
      border-bottom: 1px solid var(--border-color);
      cursor: pointer;
    }
    
    .search-suggestion:hover,
    .search-suggestion.selected {
      background-color: var(--bg-color);
    }
    
    .search-suggestion-title {
      font-weight: bold;
      font-size: 14px;
    }
    
    .search-suggestion-info {
      color: var(--primary-color);
      font-size: 12px;
    }
    
    .templates-modal {
      width: 700px;
    }
    
    .template-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      margin-bottom: 20px;
    }
    
    .template-item {
      border: 2px solid var(--border-color);
      border-radius: 8px;
      padding: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
    }
    
    .template-item:hover {
      border-color: var(--primary-color);
      transform: translateY(-5px);
      box-shadow: 0 5px 15px var(--shadow-color);
    }
    
    .template-item.active {
      border-color: var(--primary-color);
      background-color: rgba(33, 150, 243, 0.1);
    }
    
    .template-preview {
      height: 50px;
      background-color: var(--bg-color);
      margin-bottom: 10px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }
    
    .template-preview-line {
      position: absolute;
      height: 4px;
      background-color: var(--primary-color);
      left: 10px;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
    }
    
    .template-title {
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .template-description {
      font-size: 12px;
      color: var(--text-color);
      opacity: 0.8;
    }
    
    .century-summary {
      margin-top: 20px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
    }
    
    .century-header {
      display: flex;
      justify-content: space-between;
      padding: 10px 15px;
      background-color: var(--bg-color);
      border-bottom: 1px solid var(--border-color);
      font-weight: bold;
    }
    
    .century-row {
      display: flex;
      padding: 10px 15px;
      border-bottom: 1px solid var(--border-color);
    }
    
    .century-row:last-child {
      border-bottom: none;
    }
    
    .century-label {
      flex: 0 0 150px;
      font-weight: bold;
    }
    
    .century-count {
      flex: 0 0 80px;
      text-align: center;
    }
    
    .century-events {
      flex: 1;
    }
    
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(33, 150, 243, 0.4); }
      70% { box-shadow: 0 0 0 10px rgba(33, 150, 243, 0); }
      100% { box-shadow: 0 0 0 0 rgba(33, 150, 243, 0); }
    }

    .background-grid {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
    }

    .vertical-grid-line {
      position: absolute;
      top: -2000px;
      height: 4000px;
      width: 1px;
      background-color: var(--grid-line-color, rgba(0,0,0,0.05));
    }

    .academic-bg {
      background-color: var(--bg-color, #f0f2f5);
      background-image: linear-gradient(0deg, rgba(66, 165, 245, 0.03) 1px, transparent 1px);
      background-size: 100% 24px;
    }

    .night-bg {
      background-color: var(--bg-color, #121212);
      background-image: radial-gradient(rgba(66, 165, 245, 0.1) 1px, transparent 1px);
      background-size: 30px 30px;
    }

    .minimal-bg {
      background-color: var(--bg-color, #f9f9f9);
    }

    .retro-bg {
      background-color: var(--bg-color, #f5f1e3);
      background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M11 18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm48 25c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-43-7c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm63 31c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM34 90c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm56-76c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM12 86c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm28-65c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm23-11c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-6 60c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm29 22c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zM32 63c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm57-13c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-9-21c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM60 91c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM35 41c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM12 60c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2z' fill='rgba(94, 72, 53, 0.05)' fill-opacity='0.1' fill-rule='evenodd'/%3E%3C/svg%3E");
    }

    .blueprint-bg {
      background-color: var(--bg-color);
      background-image: linear-gradient(var(--grid-line-color) 1px, transparent 1px),
                        linear-gradient(90deg, var(--grid-line-color) 1px, transparent 1px);
      background-size: 20px 20px;
    }

    .dots-bg {
      background-color: var(--bg-color);
      background-image: radial-gradient(var(--grid-line-color) 1px, transparent 1px);
      background-size: 15px 15px;
    }

    .waves-bg {
      background-color: var(--bg-color);
      background-image: url("data:image/svg+xml,%3Csvg width='100' height='20' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 10 C 30 20, 70 0, 100 10 L 100 0 L 0 0 Z' fill='rgba(66, 165, 245, 0.03)'/%3E%3C/svg%3E");
      background-size: 100px 20px;
    }

    .geometric-bg {
      background-color: var(--bg-color);
      background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0 L30 30 L0 60 Z' fill='rgba(66, 165, 245, 0.03)'/%3E%3Cpath d='M60 0 L30 30 L60 60 Z' fill='rgba(66, 165, 245, 0.03)'/%3E%3C/svg%3E");
      background-size: 60px 60px;
    }

    .paper-bg {
      background-color: var(--bg-color);
      background-image: linear-gradient(90deg, rgba(66, 165, 245, 0.03) 1px, transparent 1px),
                        linear-gradient(rgba(66, 165, 245, 0.03) 1px, transparent 1px);
      background-size: 40px 40px;
    }
    
    .white-bg {
      background-color: white !important;
    }
    
    .white-bg * {
      --bg-color: white;
      --text-color: #333;
      --card-bg: white;
    }
    
    .position-dialog {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--card-bg);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 16px var(--shadow-color);
      z-index: 1001;
      color: var(--text-color);
      width: 400px;
    }
    
    .position-dialog.active {
      display: block;
    }
    
    .position-dialog h3 {
      margin-bottom: 15px;
    }
    
    .position-option {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .position-option input[type="radio"] {
      margin-right: 10px;
    }
    
    .position-dialog-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }
    
    .position-dialog-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .position-dialog-auto {
      background: var(--primary-color);
      color: white;
    }
    
    .position-dialog-below {
      background: var(--primary-dark);
      color: white;
    }

    .show-vertical-lines .vertical-grid-line {
      display: block;
    }
    
    .mobile-expanded {
      display: flex !important;
      position: fixed;
      top: 70px;
      right: 20px;
      background: var(--card-bg);
      box-shadow: 0 4px 8px var(--shadow-color);
      border-radius: 8px;
      padding: 10px;
      z-index: 997;
    }

    @media (max-width: 768px) {
      .action-buttons {
        top: 200px;
        right: 20px;
      }
      
      .zoom-control-horizontal {
        display: none;
      }
      
      .zoom-icon {
        display: flex;
        top: 20px;
      }
      
      .search-container {
        display: none;
      }
      
      .search-icon {
        display: flex;
        top: 80px;
      }
      
      .event-form, .modal {
        width: 95%;
        max-width: none;
      }
      
      .form-row {
        flex-direction: column;
        gap: 5px;
      }
      
      .stat-card {
        flex: 1 1 100%;
      }
      
      /* Melhorar responsividade mobile para timeline */
      .timeline-container {
        padding: 20px 0;
      }
      
      .period-top-bar {
        height: 16px;
        touch-action: pan-y;
      }
      
      .event-flag {
        touch-action: none;
      }
      
      .add-btn {
        width: 36px;
        height: 36px;
      }
    }
    
    .pdf-container {
      font-family: 'Segoe UI', sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 40px;
      background-color: white;
    }
    
    .pdf-header {
      text-align: center;
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 2px solid #2196f3;
    }
    
    .pdf-title {
      font-size: 28px;
      color: #1565C0;
      margin-bottom: 10px;
    }
    
    .pdf-subtitle {
      font-size: 16px;
      color: #555;
    }
    
    .pdf-timeline {
      position: relative;
      margin: 40px 0;
      padding: 20px;
      overflow: visible !important;
    }
    
    .pdf-meta {
      margin-top: 30px;
      font-size: 12px;
      color: #777;
      text-align: right;
    }
    
    .pdf-watermark {
      position: absolute;
      bottom: 20px;
      right: 20px;
      font-size: 12px;
      color: #aaa;
      opacity: 0.5;
    }
    
    .century-summary-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      margin-top: 20px;
    }
    
    .century-card {
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
    }
    
    .century-card-header {
      display: flex;
      justify-content: space-between;
      padding: 10px 15px;
      background-color: var(--bg-color);
      border-bottom: 1px solid var(--border-color);
    }
    
    .century-card-title {
      font-weight: bold;
    }
    
    .century-card-count {
      color: var(--primary-color);
      font-weight: bold;
    }
    
    .century-card-content {
      padding: 10px 15px;
    }
    
    .century-event-item {
      display: flex;
      margin-bottom: 5px;
      font-size: 13px;
    }
    
    .century-event-year {
      flex: 0 0 60px;
      color: var(--primary-color);
    }
    
    .century-event-title {
      flex: 1;
      display: flex;
      align-items: center;
    }
  </style>
</head>
<body>
<!-- Modal de seleção de idioma -->
<div class="language-modal" id="language-modal">
  <div class="language-selector">
    <h2 id="language-title">Escolha seu idioma / Choose your language / Elige tu idioma</h2>
    <div class="language-options">
      <div class="language-option selected" data-lang="pt">
        <div class="language-flag">🇧🇷</div>
        <div class="language-name">Português</div>
        <div class="language-native">Brasileiro</div>
      </div>
      <div class="language-option" data-lang="en">
        <div class="language-flag">🇺🇸</div>
        <div class="language-name">English</div>
        <div class="language-native">American</div>
      </div>
      <div class="language-option" data-lang="es">
        <div class="language-flag">🇪🇸</div>
        <div class="language-name">Español</div>
        <div class="language-native">Castellano</div>
      </div>
    </div>
    <button class="language-confirm" id="language-confirm">Confirmar</button>
  </div>
</div>


<div class="zoom-icon" data-i18n-title="zoom_control">
  <svg viewBox="0 0 24 24" width="20" height="20">
    <path fill="currentColor" d="M15.5,14L20.5,19L19,20.5L14,15.5V14.71L13.73,14.43C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.43,13.73L14.71,14H15.5M9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14M12,10H10V12H9V10H7V9H9V7H10V9H12V10Z"></path>
  </svg>
</div>

<div class="search-container">
  <div class="search-wrapper">
    <input type="text" class="search-input" data-i18n-placeholder="search_timeline" aria-label="Buscar na linha do tempo">
    <button class="search-button" data-i18n-aria="search">
      <svg viewBox="0 0 24 24" width="20" height="20">
        <path fill="currentColor" d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
      </svg>
    </button>
  </div>
  <div class="search-autocomplete"></div>
</div>

<div class="search-icon" data-i18n-title="search_timeline">
  <svg viewBox="0 0 24 24" width="20" height="20">
    <path fill="currentColor" d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
  </svg>
</div>

<div class="search-results">
  <!-- Resultados da busca serão exibidos aqui -->
</div>

<div id="character-description-popup" style="position: fixed; top: 20px; left: 20px; padding: 10px; background: var(--card-bg); border-radius: 6px; box-shadow: 0 2px 8px var(--shadow-color); max-width: 250px; font-size: 12px; display: none; z-index: 1001; line-height: 1.4; color: var(--text-color);">
  <p id="character-popup-description-text"></p>
</div>

<div class="timeline-container" id="timeline-container">
  <div class="timeline-horizontal">
    <div class="background-grid" id="background-grid"></div>
    <div class="timeline-line"></div>
    <div class="date-markers"></div>
  </div>
</div>

<div id="period-description-box" style="position: fixed; top: 20px; left: 20px; padding: 12px; background: var(--card-bg); border-radius: 8px; box-shadow: 0 2px 8px var(--shadow-color); max-width: 300px; font-size: 12px; display: none; z-index: 1001; color: var(--text-color);">
  <strong id="period-title" style="font-size: 18px; display: block; margin-bottom: 8px;"></strong>
  <span id="period-years" style="color: var(--text-color);"></span>
  <p id="period-description" style="margin-top: 8px;"></p>
</div>

<div class="toast-container">
  <!-- Aqui aparecerão os toasts de notificação -->
</div>
<div class="action-buttons">
  <button class="add-btn add-person-btn" data-i18n-title="add_character" data-i18n-aria="add_character">
    <svg viewBox="0 0 24 24" width="24" height="24">
      <path fill="currentColor" d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0-6c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm0 7c-2.67 0-8 1.34-8 4v3h16v-3c0-2.66-5.33-4-8-4zm6 5H6v-.99c.2-.72 3.3-2.01 6-2.01s5.8 1.29 6 2v1z"></path>
    </svg>
  </button>
  <button class="add-btn add-period-btn" data-i18n-title="add_period" data-i18n-aria="add_period">
    <svg viewBox="0 0 24 24" width="24" height="24">
      <path fill="currentColor" d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V9h14v10zm0-12H5V5h14v2zM7 11h5v5H7z"></path>
    </svg>
  </button>
  <button class="add-btn add-event-btn" data-i18n-title="add_event" data-i18n-aria="add_event">
    <svg viewBox="0 0 24 24" width="24" height="24">
      <path fill="currentColor" d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6h-5.6z"></path>
    </svg>
  </button>
  <button class="add-btn lock-all-btn" id="lock-all-btn" data-i18n-title="lock_unlock_all">
    <svg viewBox="0 0 24 24" width="20" height="20">
      <path fill="currentColor" d="M18,8A2,2 0 0,1 20,10V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V10A2,2 0 0,1 6,8H15V6A3,3 0 0,0 12,3A3,3 0 0,0 9,6H7A5,5 0 0,1 12,1A5,5 0 0,1 17,6V8H18M12,17A2,2 0 0,0 14,15A2,2 0 0,0 12,13A2,2 0 0,0 10,15A2,2 0 0,0 12,17Z"></path>
    </svg>
  </button>
  <button class="add-btn menu-btn" data-i18n-title="menu" data-i18n-aria="menu">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="white" d="M3 6h18v2h-18v-2zm0 5h18v2h-18v-2zm0 5h18v2h-18v-2z"></path></svg>
  </button>

  <div class="dropdown-content">
    <button class="add-btn load-btn" data-i18n-title="load" data-i18n-aria="load">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <path fill="currentColor" d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"></path>
      </svg>
    </button>
    <button class="add-btn save-btn" data-i18n-title="save" data-i18n-aria="save">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <path fill="currentColor" d="M15,9H5V5H15M12,19A3,3 0 0,1 9,16A3,3 0 0,1 12,13A3,3 0 0,1 15,16A3,3 0 0,1 12,19M17,3H5C3.89,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V7L17,3Z"></path>
      </svg>
    </button>
    
    <button class="add-btn help-btn" data-i18n-title="help" data-i18n-aria="help">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <path fill="currentColor" d="M15.07,11.25L14.17,12.17C13.45,12.89 13,13.5 13,15H11V14.5C11,13.39 11.45,12.39 12.17,11.67L13.41,10.41C13.78,10.05 14,9.55 14,9C14,7.89 13.1,7 12,7A2,2 0 0,0 10,9H8A4,4 0 0,1 12,5A4,4 0 0,1 16,9C16,9.88 15.64,10.67 15.07,11.25M13,19H11V17H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12C22,6.47 17.5,2 12,2Z"></path>
      </svg>
    </button>
    
    <button class="add-btn settings-main-btn" data-i18n-title="settings" data-i18n-aria="settings">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <path fill="currentColor" d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.67 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"></path>
      </svg>
    </button>
  </div>

  <!-- Controle de Zoom Horizontal -->
  <div class="zoom-control-horizontal">
    <div class="zoom-label" data-i18n="zoom">Zoom</div>
    <input type="range" class="zoom-slider" min="0" max="100" value="0" aria-label="Controle de zoom">
    <div class="zoom-percentage">0%</div>
  </div>
</div>
<div class="overlay"></div>

<!-- Modal de Configurações -->
<div class="settings-modal" id="settings-modal">
  <div class="settings-window">
    <div class="settings-header">
      <h2 class="settings-title">
        <svg viewBox="0 0 24 24" width="28" height="28">
          <path fill="currentColor" d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.67 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"></path>
        </svg>
        <span>Configurações</span>
      </h2>
      <button class="settings-close">×</button>
    </div>
    
    <div class="settings-content">
      <!-- Seção Aparência -->
      <div class="settings-section">
        <h3 class="settings-section-title">
          <svg viewBox="0 0 24 24" width="20" height="20">
            <path fill="currentColor" d="M12,18V6A6,6 0 0,1 18,12A6,6 0 0,1 12,18M20,15.31L23.31,12L20,8.69V4H15.31L12,0.69L8.69,4H4V8.69L0.69,12L4,15.31V20H8.69L12,23.31L15.31,20H20V15.31Z"/>
          </svg>
          <span>Aparência</span>
        </h3>
        
        <div class="settings-option dark-mode-option">
          <div class="settings-option-info">
            <svg class="settings-option-icon" viewBox="0 0 24 24">
              <path fill="currentColor" d="M12,18V6A6,6 0 0,1 18,12A6,6 0 0,1 12,18M20,15.31L23.31,12L20,8.69V4H15.31L12,0.69L8.69,4H4V8.69L0.69,12L4,15.31V20H8.69L12,23.31L15.31,20H20V15.31Z"/>
            </svg>
            <div class="settings-option-text">
              <div class="settings-option-title">Modo Escuro</div>
            </div>
          </div>
          <button class="settings-toggle" id="dark-mode-toggle"></button>
        </div>
      </div>

      <!-- Seção Dados e Exportação -->
      <div class="settings-section">
        <h3 class="settings-section-title">
          <svg viewBox="0 0 24 24" width="20" height="20">
            <path fill="currentColor" d="M5,3H19A2,2 0 0,1 21,5V19A2,2 0 0,1 19,21H5A2,2 0 0,1 3,19V5A2,2 0 0,1 5,3M9,17H7V10H9V17M13,17H11V7H13V17M17,17H15V13H17V17Z"/>
          </svg>
          <span>Dados e Exportação</span>
        </h3>
        
        <div class="settings-option stats-option">
          <div class="settings-option-info">
            <svg class="settings-option-icon" viewBox="0 0 24 24">
              <path fill="currentColor" d="M5,3H19A2,2 0 0,1 21,5V19A2,2 0 0,1 19,21H5A2,2 0 0,1 3,19V5A2,2 0 0,1 5,3M9,17H7V10H9V17M13,17H11V7H13V17M17,17H15V13H17V17Z"/>
            </svg>
            <div class="settings-option-text">
              <div class="settings-option-title">Estatísticas</div>
            </div>
          </div>
          <button class="settings-button" id="view-stats-btn">
            <span>Ver</span>
          </button>
        </div>
        
        <div class="settings-option export-png-option">
          <div class="settings-option-info">
            <svg class="settings-option-icon" viewBox="0 0 24 24">
              <path fill="currentColor" d="M5,2C3.89,2 3,2.89 3,4V20A2,2 0 0,0 5,22H19A2,2 0 0,0 21,20V8L15,2H5M5,4H14V8H19V18L17,16L15.5,17.5L13,15L9.5,18.5L8,17L5,20V4Z"/>
            </svg>
            <div class="settings-option-text">
              <div class="settings-option-title">Exportar PNG</div>
            </div>
          </div>
          <button class="settings-button" id="export-png-btn">
            <span>Exportar</span>
          </button>
        </div>
        
        <div class="settings-option export-pdf-option">
          <div class="settings-option-info">
            <svg class="settings-option-icon" viewBox="0 0 24 24">
              <path fill="currentColor" d="M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M9.5,17A1.5,1.5 0 0,0 11,15.5V14.5A1.5,1.5 0 0,0 9.5,13H7V17H9.5M8,14H9V15H8V14M12,17H14A2,2 0 0,0 16,15V14A2,2 0 0,0 14,12H12V17M13,13H14A1,1 0 0,1 15,14V15A1,1 0 0,1 14,16H13V13M16,17H20V16H17V15H19.5V14H17V13H20V12H16V17Z"/>
            </svg>
            <div class="settings-option-text">
              <div class="settings-option-title">Exportar PDF</div>
            </div>
          </div>
          <button class="settings-button" id="export-pdf-btn">
            <span>Exportar</span>
          </button>
        </div>
        
        <div class="settings-option clear-all-option">
          <div class="settings-option-info">
            <svg class="settings-option-icon" viewBox="0 0 24 24">
              <path fill="currentColor" d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z"/>
            </svg>
            <div class="settings-option-text">
              <div class="settings-option-title">Limpar Tudo</div>
            </div>
          </div>
          <button class="settings-button" id="clear-all-btn" style="background: var(--error-color);">
            <span>Limpar</span>
          </button>
        </div>
      </div>

      <!-- Seção Ferramentas -->
      <div class="settings-section">
        <h3 class="settings-section-title">
          <svg viewBox="0 0 24 24" width="20" height="20">
            <path fill="currentColor" d="M20,11H4V8H20M20,15H13V13H20M20,19H13V17H20M11,19H4V13H11M20.33,4.67L18.67,3L17,4.67L15.33,3L13.67,4.67L12,3L10.33,4.67L8.67,3L7,4.67L5.33,3L3.67,4.67L2,3V19A2,2 0 0,0 4,21H20A2,2 0 0,0 22,19V3L20.33,4.67Z"/>
          </svg>
          <span>Ferramentas</span>
        </h3>
        
        <div class="settings-option keyboard-option">
          <div class="settings-option-info">
            <svg class="settings-option-icon" viewBox="0 0 24 24">
              <path fill="currentColor" d="M19,10H17V8H19M19,13H17V11H19M16,10H14V8H16M16,13H14V11H16M16,17H8V15H16M7,10H5V8H7M7,13H5V11H7M8,11H10V13H8M8,8H10V10H8M11,11H13V13H11M11,8H13V10H11M20,5H4C2.89,5 2,5.89 2,7V17A2,2 0 0,0 4,19H20A2,2 0 0,0 22,17V7C22,5.89 21.1,5 20,5Z"/>
            </svg>
            <div class="settings-option-text">
              <div class="settings-option-title">Atalhos de Teclado</div>
            </div>
          </div>
          <button class="settings-button" id="view-keyboard-btn">
            <span>Ver</span>
          </button>
        </div>
        
        <div class="settings-option template-option">
          <div class="settings-option-info">
            <svg class="settings-option-icon" viewBox="0 0 24 24">
              <path fill="currentColor" d="M20,11H4V8H20M20,15H13V13H20M20,19H13V17H20M11,19H4V13H11M20.33,4.67L18.67,3L17,4.67L15.33,3L13.67,4.67L12,3L10.33,4.67L8.67,3L7,4.67L5.33,3L3.67,4.67L2,3V19A2,2 0 0,0 4,21H20A2,2 0 0,0 22,19V3L20.33,4.67Z"/>
            </svg>
            <div class="settings-option-text">
              <div class="settings-option-title">Templates</div>
            </div>
          </div>
          <button class="settings-button" id="load-template-btn">
            <span>Carregar</span>
          </button>
        </div>
      </div>

      <!-- Seção Idioma -->
      <div class="settings-section">
        <h3 class="settings-section-title">
          <svg viewBox="0 0 24 24" width="20" height="20">
            <path fill="currentColor" d="M17.9,17.39C17.64,16.59 16.89,16 16,16H15V13A1,1 0 0,0 14,12H8V10H10A1,1 0 0,0 11,9V7H13A2,2 0 0,0 15,5V4.59C17.93,5.77 20,8.64 20,12C20,14.08 19.2,15.97 17.9,17.39M11,19.93C7.05,19.44 4,16.08 4,12C4,11.38 4.08,10.78 4.21,10.21L9,15V16A2,2 0 0,0 11,18M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z"/>
          </svg>
          <span>Idioma</span>
        </h3>
        
        <div class="settings-option language-option">
          <div class="settings-option-info">
            <svg class="settings-option-icon" viewBox="0 0 24 24">
              <path fill="currentColor" d="M17.9,17.39C17.64,16.59 16.89,16 16,16H15V13A1,1 0 0,0 14,12H8V10H10A1,1 0 0,0 11,9V7H13A2,2 0 0,0 15,5V4.59C17.93,5.77 20,8.64 20,12C20,14.08 19.2,15.97 17.9,17.39M11,19.93C7.05,19.44 4,16.08 4,12C4,11.38 4.08,10.78 4.21,10.21L9,15V16A2,2 0 0,0 11,18M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z"/>
            </svg>
            <div class="settings-option-text">
              <div class="settings-option-title">Alterar Idioma</div>
            </div>
          </div>
          <button class="settings-button" id="change-language-btn">
            <span>Alterar</span>
          </button>
        </div>
      </div>
    </div>
  </div>
</div>
<form class="event-form">
  <div class="form-group event-fields">
    <label for="event-year" data-i18n="year_label">Ano (use - para A.C.):</label>
    <input type="number" id="event-year" required="" class="autocomplete-input">
    <div class="autocomplete-suggestions"></div>
    <label for="event-color" data-i18n="event_color">Cor do Evento:</label>
    <input type="color" id="event-color" value="#4676E0">
    <label for="event-opacity" data-i18n="transparency">Transparência:</label>
    <input type="range" id="event-opacity" min="0" max="100" value="100" style="width: 120px;">
    <span id="event-opacity-value">100%</span>
  </div>
  <div class="form-group person-fields" style="display:none">
    <label data-i18n="character_period">Personagem - Período do Personagem</label>
    <div class="form-row">
      <div class="form-group autocomplete-container">
        <label for="birth-year" data-i18n="start_date">Data Inicial:</label>
        <input type="number" id="birth-year" required="" class="autocomplete-input">
        <div class="autocomplete-suggestions"></div>
      </div>
      <div style="display: flex; align-items: center; padding: 0 10px;">
        <span data-i18n="until">até</span>
      </div>
      <div class="form-group autocomplete-container">
        <label for="death-year" data-i18n="end_date">Data Final:</label>
        <input type="number" id="death-year" required="" class="autocomplete-input">
        <div class="autocomplete-suggestions"></div>
      </div>
    </div>
    <div class="form-row checkbox-container">
      <div class="checkbox-wrapper">
        <input type="checkbox" id="imprecise-birth">
        <label for="imprecise-birth" data-i18n="approximate_start">Data inicial aproximada</label>
      </div>
      <div class="checkbox-wrapper">
        <input type="checkbox" id="imprecise-death">
        <label for="imprecise-death" data-i18n="approximate_end">Data final aproximada</label>
      </div>
    </div>
    <label for="person-color" data-i18n="character_color">Cor do Personagem:</label>
    <input type="color" id="person-color" value="#4676E0">
    <label for="person-opacity" data-i18n="transparency">Transparência:</label>
    <input type="range" id="person-opacity" min="0" max="100" value="100" style="width: 120px;">
    <span id="person-opacity-value">100%</span>
  </div>
  <div class="form-group">
    <label for="event-title" data-i18n="title">Título:</label>
    <input type="text" id="event-title" required="">
  </div>
  <div class="form-group">
    <label for="event-description" data-i18n="description">Descrição:</label>
    <textarea id="event-description"></textarea>
  </div>
  <div id="form-error"></div>
  <div class="form-buttons">
    <button type="button" class="cancel-btn" data-i18n="cancel">Cancelar</button>
    <button type="submit" class="form-save-btn" data-i18n="save">Salvar</button>
  </div>
</form>

<div class="position-dialog" id="position-dialog">
  <h3 data-i18n="position_character">Como deseja posicionar o personagem?</h3>
  
  <div class="position-option">
    <input type="radio" id="position-dialog-auto" name="position-dialog" value="auto" checked="">
    <label for="position-dialog-auto" data-i18n="auto_adjust">Ajustar automaticamente</label>
  </div>
  
  <div class="position-option">
    <input type="radio" id="position-dialog-below" name="position-dialog" value="below">
    <label for="position-dialog-below" data-i18n="add_below">Adicionar abaixo (manter outros na mesma posição)</label>
  </div>
  
  <div class="position-dialog-buttons">
    <button type="button" class="position-dialog-auto" id="position-dialog-confirm" data-i18n="confirm">Confirmar</button>
  </div>
</div>

<div class="context-menu">
  <div class="context-menu-item edit" data-i18n="edit">Editar</div>
  <div class="context-menu-item toggle-lock" id="context-toggle-lock" data-i18n="lock_position">Travar posição</div>
  <div class="context-menu-item delete" data-i18n="delete">Apagar</div>
</div>

<!-- Modal de Estatísticas -->
<div id="stats-modal" class="modal">
  <button class="close-modal">×</button>
  <h2 class="modal-title" data-i18n="timeline_stats">Estatísticas da Linha do Tempo</h2>
  <div class="stats-container">
    <div class="stat-card">
      <div class="stat-value" id="total-events">0</div>
      <div class="stat-label" data-i18n="total_events">Total de Eventos</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="total-persons">0</div>
      <div class="stat-label" data-i18n="total_characters">Total de Personagens</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="total-periods">0</div>
      <div class="stat-label" data-i18n="total_periods">Total de Períodos</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="earliest-year">-</div>
      <div class="stat-label" data-i18n="earliest_year">Ano Mais Antigo</div>
    </div>
    <div class="stat-card">
      <div class="stat-value" id="latest-year">-</div>
      <div class="stat-label" data-i18n="latest_year">Ano Mais Recente</div>
    </div>
  </div>
  
  <h3 data-i18n="century_summary">Resumo por Séculos</h3>
  <div class="century-summary-grid" id="century-content">
    <!-- Conteúdo será preenchido pelo JavaScript -->
  </div>
</div>

<!-- Modal de Atalhos de Teclado -->
<div id="keyboard-modal" class="modal">
  <button class="close-modal">×</button>
  <h2 class="modal-title" data-i18n="keyboard_shortcuts">Atalhos de Teclado</h2>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description" data-i18n="add_event_shortcut">Adicionar evento</div>
    <div class="shortcut-keys">
      <div class="key">Alt</div>
      <div class="key">E</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description" data-i18n="add_character_shortcut">Adicionar personagem</div>
    <div class="shortcut-keys">
      <div class="key">Alt</div>
      <div class="key">P</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description" data-i18n="add_period_shortcut">Adicionar período</div>
    <div class="shortcut-keys">
      <div class="key">Alt</div>
      <div class="key">T</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description" data-i18n="save_timeline_shortcut">Salvar linha do tempo</div>
    <div class="shortcut-keys">
      <div class="key">Ctrl</div>
      <div class="key">S</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description" data-i18n="load_timeline_shortcut">Carregar linha do tempo</div>
    <div class="shortcut-keys">
      <div class="key">Ctrl</div>
      <div class="key">O</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description" data-i18n="export_png_shortcut">Exportar como PNG</div>
    <div class="shortcut-keys">
      <div class="key">Ctrl</div>
      <div class="key">I</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description" data-i18n="export_pdf_shortcut">Exportar como PDF</div>
    <div class="shortcut-keys">
      <div class="key">Ctrl</div>
      <div class="key">P</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description" data-i18n="toggle_dark_mode_shortcut">Alternar modo escuro</div>
    <div class="shortcut-keys">
      <div class="key">Alt</div>
      <div class="key">D</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description" data-i18n="open_help_shortcut">Abrir ajuda</div>
    <div class="shortcut-keys">
      <div class="key">F1</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description" data-i18n="zoom_in_shortcut">Aumentar zoom</div>
    <div class="shortcut-keys">
      <div class="key">+</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description" data-i18n="zoom_out_shortcut">Diminuir zoom</div>
    <div class="shortcut-keys">
      <div class="key">-</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description" data-i18n="navigate_left_shortcut">Navegar para esquerda</div>
    <div class="shortcut-keys">
      <div class="key">←</div>
    </div>
  </div>
  
  <div class="keyboard-shortcut">
    <div class="shortcut-description" data-i18n="navigate_right_shortcut">Navegar para direita</div>
    <div class="shortcut-keys">
      <div class="key">→</div>
    </div>
  </div>
</div>

<!-- Modal de Tutorial -->
<div id="tutorial-modal" class="modal">
  <button class="close-modal">×</button>
  <h2 class="modal-title" data-i18n="tutorial_title">Tutorial: Como Usar a Linha do Tempo</h2>
  
  <div class="tutorial-step">
    <span class="tutorial-step-number">1</span>
    <span class="tutorial-step-title" data-i18n="step_navigation_title">Navegação Básica</span>
    <p data-i18n="step_navigation_desc">Use o mouse para arrastar a linha do tempo horizontalmente. Gire a roda do mouse enquanto pressiona Ctrl para aumentar ou diminuir o zoom. Use os botões + e - no teclado para ajustar o zoom rapidamente.</p>
  </div>
  
  <div class="tutorial-step">
    <span class="tutorial-step-number">2</span>
    <span class="tutorial-step-title" data-i18n="step_content_title">Adicionando Conteúdo</span>
    <p data-i18n="step_content_desc">Use os botões na barra superior direita para adicionar diferentes tipos de conteúdo:</p>
    <ul>
      <li><strong data-i18n="character">Personagem:</strong> <span data-i18n="character_desc">Indivíduos com datas de nascimento e morte</span></li>
      <li><strong data-i18n="event">Evento:</strong> <span data-i18n="event_desc">Momentos específicos no tempo</span></li>
      <li><strong data-i18n="period">Período:</strong> <span data-i18n="period_desc">Intervalos de tempo com início e fim</span></li>
    </ul>
  </div>
  
  <div class="tutorial-step">
    <span class="tutorial-step-number">3</span>
    <span class="tutorial-step-title" data-i18n="step_customize_title">Personalizando Eventos</span>
    <p data-i18n="step_customize_desc">Clique com o botão direito em qualquer evento ou personagem para editar ou excluir. Você pode personalizar cores e níveis de transparência.</p>
  </div>
  
  <div class="tutorial-step">
    <span class="tutorial-step-number">4</span>
    <span class="tutorial-step-title" data-i18n="step_save_title">Salvando e Compartilhando</span>
    <p data-i18n="step_save_desc">Use o menu para salvar sua linha do tempo em formato JSON. Também é possível exportar como PNG para compartilhar ou PDF para imprimir.</p>
  </div>
  
  <div class="tutorial-step">
    <span class="tutorial-step-number">5</span>
    <span class="tutorial-step-title" data-i18n="step_language_title">Alterando Idioma</span>
    <p data-i18n="step_language_desc">Você pode alterar o idioma da interface a qualquer momento clicando no ícone de configurações e selecionando "Idioma". O aplicativo suporta português, inglês e espanhol.</p>
  </div>
  
  <div class="tutorial-step">
    <span class="tutorial-step-number">6</span>
    <span class="tutorial-step-title" data-i18n="step_advanced_title">Dicas Avançadas</span>
    <p data-i18n="step_advanced_desc">Para maior eficiência, use os atalhos de teclado listados no painel "Atalhos de Teclado". Personagens podem ser reordenados verticalmente arrastando-os para cima ou para baixo.</p>
    <p data-i18n="step_lock_desc">Para personagens, você pode travar/destravar a posição clicando com o botão direito sobre eles, ou usar o botão de cadeado para travar/destravar todos de uma vez.</p>
  </div>
</div>

<!-- Modal de Templates -->
<div id="templates-modal" class="modal templates-modal">
  <button class="close-modal">×</button>
  <h2 class="modal-title" data-i18n="templates_title">Templates para Linha do Tempo</h2>
  
  <div class="template-grid">
    <div class="template-item active" data-template="default" data-show-grid="false">
      <div class="template-preview">
        <div class="template-preview-line"></div>
      </div>
      <div class="template-title" data-i18n="template_default">Padrão</div>
      <div class="template-description" data-i18n="template_default_desc">Linha do tempo clássica com todos os recursos</div>
    </div>
    
    <div class="template-item" data-template="history" data-show-grid="false">
      <div class="template-preview">
        <div class="template-preview-line" style="background-color: #8C6E63;"></div>
      </div>
      <div class="template-title" data-i18n="template_history">História Mundial</div>
      <div class="template-description" data-i18n="template_history_desc">Focado em eventos históricos importantes</div>
    </div>
    
    <div class="template-item" data-template="biography" data-show-grid="false">
      <div class="template-preview">
        <div class="template-preview-line" style="background-color: #4CAF50;"></div>
      </div>
      <div class="template-title" data-i18n="template_biography">Biografia</div>
      <div class="template-description" data-i18n="template_biography_desc">Ideal para traçar a vida de personagens</div>
    </div>
    
    <div class="template-item" data-template="project" data-show-grid="true">
      <div class="template-preview">
        <div class="template-preview-line" style="background-color: #FF5722;"></div>
      </div>
      <div class="template-title" data-i18n="template_project">Projeto</div>
      <div class="template-description" data-i18n="template_project_desc">Para planejamento e marcos de projetos</div>
    </div>
    
    <div class="template-item" data-template="science" data-show-grid="false">
      <div class="template-preview">
        <div class="template-preview-line" style="background-color: #2196F3;"></div>
      </div>
      <div class="template-title" data-i18n="template_science">Ciência</div>
      <div class="template-description" data-i18n="template_science_desc">Descobertas e avanços científicos</div>
    </div>
    
    <div class="template-item" data-template="blueprint" data-show-grid="true">
      <div class="template-preview blueprint-bg">
        <div class="template-preview-line" style="background-color: #3F51B5;"></div>
      </div>
      <div class="template-title" data-i18n="template_blueprint">Blueprint</div>
      <div class="template-description" data-i18n="template_blueprint_desc">Estilo grade com linhas verticais alinhadas</div>
    </div>
    
    <div class="template-item" data-template="dots" data-show-grid="true">
      <div class="template-preview dots-bg">
        <div class="template-preview-line" style="background-color: #9C27B0;"></div>
      </div>
      <div class="template-title" data-i18n="template_dots">Pontilhado</div>
      <div class="template-description" data-i18n="template_dots_desc">Fundo com pontos e linhas verticais</div>
    </div>
    
    <div class="template-item" data-template="waves" data-show-grid="true">
      <div class="template-preview waves-bg">
        <div class="template-preview-line" style="background-color: #FF9800;"></div>
      </div>
      <div class="template-title" data-i18n="template_waves">Ondas</div>
      <div class="template-description" data-i18n="template_waves_desc">Padrão de ondas suaves com linhas</div>
    </div>
    
    <div class="template-item" data-template="geometric" data-show-grid="false">
      <div class="template-preview geometric-bg">
        <div class="template-preview-line" style="background-color: #607D8B;"></div>
      </div>
      <div class="template-title" data-i18n="template_geometric">Geométrico</div>
      <div class="template-description" data-i18n="template_geometric_desc">Padrões geométricos sutis</div>
    </div>
    
    <div class="template-item" data-template="paper" data-show-grid="false">
      <div class="template-preview paper-bg">
        <div class="template-preview-line" style="background-color: #795548;"></div>
      </div>
      <div class="template-title" data-i18n="template_paper">Papel</div>
      <div class="template-description" data-i18n="template_paper_desc">Visual tipo folha de papel milimetrado</div>
    </div>
    
    <div class="template-item" data-template="white" data-show-grid="true">
      <div class="template-preview white-bg">
        <div class="template-preview-line" style="background-color: #666;"></div>
      </div>
      <div class="template-title" data-i18n="template_white">Fundo Branco</div>
      <div class="template-description" data-i18n="template_white_desc">Fundo branco com linhas de grade em cinza</div>
    </div>
  </div>
  
  <div class="form-buttons">
    <button type="button" class="cancel-btn" data-i18n="cancel">Cancelar</button>
    <button type="button" class="form-save-btn" id="apply-template" data-i18n="apply_template">Aplicar Template</button>
  </div>
</div>

<script>
// Sistema de Internacionalização
const translations = {
  pt: {
    // Títulos de página e modais
    page_title: "Linha do Tempo Histórica",
    timeline_stats: "Estatísticas da Linha do Tempo",
    keyboard_shortcuts: "Atalhos de Teclado",
    tutorial_title: "Tutorial: Como Usar a Linha do Tempo",
    templates_title: "Templates para Linha do Tempo",
    
    // Botões principais
    add_character: "Adicionar Personagem",
    add_event: "Adicionar Evento",
    add_period: "Adicionar Período",
    settings: "Configurações",
    menu: "Menu",
    
    // Menu de configurações
    dark_mode: "Modo Escuro",
    statistics: "Estatísticas",
    templates: "Templates",
    language: "Idioma",
    
    // Ações de arquivo
    load: "Carregar",
    save: "Salvar",
    export_png: "Exportar como PNG",
    export_pdf: "Exportar como PDF",
    help: "Ajuda",
    clear_all: "Limpar Tudo",
    
    // Formulários
    title: "Título",
    description: "Descrição",
    year_label: "Ano (use - para A.C.)",
    event_color: "Cor do Evento",
    character_color: "Cor do Personagem",
    transparency: "Transparência",
    character_period: "Personagem - Período do Personagem",
    start_date: "Data Inicial",
    end_date: "Data Final",
    until: "até",
    approximate_start: "Data inicial aproximada",
    approximate_end: "Data final aproximada",
    cancel: "Cancelar",
    confirm: "Confirmar",
    
    // Posicionamento
    position_character: "Como deseja posicionar o personagem?",
    auto_adjust: "Ajustar automaticamente",
    add_below: "Adicionar abaixo (manter outros na mesma posição)",
    
    // Menu de contexto
    edit: "Editar",
    lock_position: "Travar posição",
    unlock_position: "Destravar posição",
    delete: "Apagar",
    
    // Busca
    search_timeline: "Buscar na linha do tempo...",
    search: "Buscar",
    zoom_control: "Controle de zoom",
    zoom: "Zoom",
    lock_unlock_all: "Travar/destravar todos os personagens",
    
    // Estatísticas
    total_events: "Total de Eventos",
    total_characters: "Total de Personagens",
    total_periods: "Total de Períodos",
    earliest_year: "Ano Mais Antigo",
    latest_year: "Ano Mais Recente",
    century_summary: "Resumo por Séculos",
    
    // Atalhos de teclado
    add_event_shortcut: "Adicionar evento",
    add_character_shortcut: "Adicionar personagem",
    add_period_shortcut: "Adicionar período",
    save_timeline_shortcut: "Salvar linha do tempo",
    load_timeline_shortcut: "Carregar linha do tempo",
    export_png_shortcut: "Exportar como PNG",
    export_pdf_shortcut: "Exportar como PDF",
    toggle_dark_mode_shortcut: "Alternar modo escuro",
    open_help_shortcut: "Abrir ajuda",
    zoom_in_shortcut: "Aumentar zoom",
    zoom_out_shortcut: "Diminuir zoom",
    navigate_left_shortcut: "Navegar para esquerda",
    navigate_right_shortcut: "Navegar para direita",
    
    // Tutorial
    step_navigation_title: "Navegação Básica",
    step_navigation_desc: "Use o mouse para arrastar a linha do tempo horizontalmente. Gire a roda do mouse enquanto pressiona Ctrl para aumentar ou diminuir o zoom. Use os botões + e - no teclado para ajustar o zoom rapidamente.",
    step_content_title: "Adicionando Conteúdo",
    step_content_desc: "Use os botões na barra superior direita para adicionar diferentes tipos de conteúdo:",
    character: "Personagem",
    character_desc: "Indivíduos com datas de nascimento e morte",
    event: "Evento",
    event_desc: "Momentos específicos no tempo",
    period: "Período",
    period_desc: "Intervalos de tempo com início e fim",
    step_customize_title: "Personalizando Eventos",
    step_customize_desc: "Clique com o botão direito em qualquer evento ou personagem para editar ou excluir. Você pode personalizar cores e níveis de transparência.",
    step_save_title: "Salvando e Compartilhando",
    step_save_desc: "Use o menu para salvar sua linha do tempo em formato JSON. Também é possível exportar como PNG para compartilhar ou PDF para imprimir.",
    step_language_title: "Alterando Idioma",
    step_language_desc: "Você pode alterar o idioma da interface a qualquer momento clicando no ícone de configurações e selecionando \"Idioma\". O aplicativo suporta português, inglês e espanhol.",
    step_advanced_title: "Dicas Avançadas",
    step_advanced_desc: "Para maior eficiência, use os atalhos de teclado listados no painel \"Atalhos de Teclado\". Personagens podem ser reordenados verticalmente arrastando-os para cima ou para baixo.",
    step_lock_desc: "Para personagens, você pode travar/destravar a posição clicando com o botão direito sobre eles, ou usar o botão de cadeado para travar/destravar todos de uma vez.",
    
    // Templates
    template_default: "Padrão",
    template_default_desc: "Linha do tempo clássica com todos os recursos",
    template_history: "História Mundial",
    template_history_desc: "Focado em eventos históricos importantes",
    template_biography: "Biografia",
    template_biography_desc: "Ideal para traçar a vida de personagens",
    template_project: "Projeto",
    template_project_desc: "Para planejamento e marcos de projetos",
    template_science: "Ciência",
    template_science_desc: "Descobertas e avanços científicos",
    template_blueprint: "Blueprint",
    template_blueprint_desc: "Estilo grade com linhas verticais alinhadas",
    template_dots: "Pontilhado",
    template_dots_desc: "Fundo com pontos e linhas verticais",
    template_waves: "Ondas",
    template_waves_desc: "Padrão de ondas suaves com linhas",
    template_geometric: "Geométrico",
    template_geometric_desc: "Padrões geométricos sutis",
    template_paper: "Papel",
    template_paper_desc: "Visual tipo folha de papel milimetrado",
    template_white: "Fundo Branco",
    template_white_desc: "Fundo branco com linhas de grade em cinza",
    apply_template: "Aplicar Template",
    
    // Mensagens
    character_added: "Personagem adicionado com sucesso",
    event_added: "Evento adicionado com sucesso",
    period_added: "Período adicionado com sucesso",
    event_updated: "Evento atualizado com sucesso",
    event_removed: "Evento removido com sucesso",
    timeline_saved: "Timeline salva com sucesso",
    timeline_loaded: "Timeline carregada com sucesso",
    all_locked: "Todos os personagens travados",
    all_unlocked: "Todos os personagens destravados",
    character_locked: "travado",
    character_unlocked: "destravado",
    flag_locked: "Flag travada",
    flag_unlocked: "Flag destravada",
    template_applied: "aplicado com sucesso",
    generating_pdf: "Gerando PDF...",
    pdf_generated: "PDF gerado com sucesso",
    generating_image: "Gerando imagem...",
    image_generated: "Imagem PNG gerada com sucesso",
    no_results: "Nenhum resultado encontrado",
    
    // Validação
    title_required: "O título é obrigatório",
    start_date_required: "A data inicial é obrigatória e deve ser um número",
    end_date_required: "A data final é obrigatória e deve ser um número",
    end_before_start: "A data final não pode ser anterior à data inicial",
    year_required: "O ano é obrigatório e deve ser um número",
    
    // Confirmações
    confirm_delete: "Tem certeza que deseja apagar este item?",
    confirm_clear: "Tem certeza que deseja limpar todos os dados e carregar um novo arquivo? Esta ação não pode ser desfeita.",
    
    // Datas
    bc: "A.C.",
    ad: "D.C.",
    age_years: "anos"
  },
  
  en: {
    // Page titles and modals
    page_title: "Historical Timeline",
    timeline_stats: "Timeline Statistics",
    keyboard_shortcuts: "Keyboard Shortcuts",
    tutorial_title: "Tutorial: How to Use the Timeline",
    templates_title: "Timeline Templates",
    
    // Main buttons
    add_character: "Add Character",
    add_event: "Add Event",
    add_period: "Add Period",
    settings: "Settings",
    menu: "Menu",
    
    // Settings menu
    dark_mode: "Dark Mode",
    statistics: "Statistics",
    templates: "Templates",
    language: "Language",
    
    // File actions
    load: "Load",
    save: "Save",
    export_png: "Export as PNG",
    export_pdf: "Export as PDF",
    help: "Help",
    clear_all: "Clear All",
    
    // Forms
    title: "Title",
    description: "Description",
    year_label: "Year (use - for BC)",
    event_color: "Event Color",
    character_color: "Character Color",
    transparency: "Transparency",
    character_period: "Character - Character Period",
    start_date: "Start Date",
    end_date: "End Date",
    until: "until",
    approximate_start: "Approximate start date",
    approximate_end: "Approximate end date",
    cancel: "Cancel",
    confirm: "Confirm",
    
    // Positioning
    position_character: "How would you like to position the character?",
    auto_adjust: "Auto adjust",
    add_below: "Add below (keep others in same position)",
    
    // Context menu
    edit: "Edit",
    lock_position: "Lock position",
    unlock_position: "Unlock position",
    delete: "Delete",
    
    // Search
    search_timeline: "Search timeline...",
    search: "Search",
    zoom_control: "Zoom control",
    zoom: "Zoom",
    lock_unlock_all: "Lock/unlock all characters",
    
    // Statistics
    total_events: "Total Events",
    total_characters: "Total Characters",
    total_periods: "Total Periods",
    earliest_year: "Earliest Year",
    latest_year: "Latest Year",
    century_summary: "Century Summary",
    
    // Keyboard shortcuts
    add_event_shortcut: "Add event",
    add_character_shortcut: "Add character",
    add_period_shortcut: "Add period",
    save_timeline_shortcut: "Save timeline",
    load_timeline_shortcut: "Load timeline",
    export_png_shortcut: "Export as PNG",
    export_pdf_shortcut: "Export as PDF",
    toggle_dark_mode_shortcut: "Toggle dark mode",
    open_help_shortcut: "Open help",
    zoom_in_shortcut: "Zoom in",
    zoom_out_shortcut: "Zoom out",
    navigate_left_shortcut: "Navigate left",
    navigate_right_shortcut: "Navigate right",
    
    // Tutorial
    step_navigation_title: "Basic Navigation",
    step_navigation_desc: "Use the mouse to drag the timeline horizontally. Hold Ctrl and scroll with the mouse wheel to zoom in or out. Use the + and - keys on the keyboard to quickly adjust zoom.",
    step_content_title: "Adding Content",
    step_content_desc: "Use the buttons in the top-right bar to add different types of content:",
    character: "Character",
    character_desc: "Individuals with birth and death dates",
    event: "Event",
    event_desc: "Specific moments in time",
    period: "Period",
    period_desc: "Time intervals with start and end",
    step_customize_title: "Customizing Events",
    step_customize_desc: "Right-click on any event or character to edit or delete. You can customize colors and transparency levels.",
    step_save_title: "Saving and Sharing",
    step_save_desc: "Use the menu to save your timeline in JSON format. You can also export as PNG to share or PDF to print.",
    step_language_title: "Changing Language",
    step_language_desc: "You can change the interface language at any time by clicking the settings icon and selecting \"Language\". The app supports Portuguese, English, and Spanish.",
    step_advanced_title: "Advanced Tips",
    step_advanced_desc: "For greater efficiency, use the keyboard shortcuts listed in the \"Keyboard Shortcuts\" panel. Characters can be reordered vertically by dragging them up or down.",
    step_lock_desc: "For characters, you can lock/unlock position by right-clicking on them, or use the lock button to lock/unlock all at once.",
    
    // Templates
    template_default: "Default",
    template_default_desc: "Classic timeline with all features",
    template_history: "World History",
    template_history_desc: "Focused on important historical events",
    template_biography: "Biography",
    template_biography_desc: "Ideal for tracing character lives",
    template_project: "Project",
    template_project_desc: "For planning and project milestones",
    template_science: "Science",
    template_science_desc: "Scientific discoveries and advances",
    template_blueprint: "Blueprint",
    template_blueprint_desc: "Grid style with aligned vertical lines",
    template_dots: "Dotted",
    template_dots_desc: "Background with dots and vertical lines",
    template_waves: "Waves",
    template_waves_desc: "Smooth wave pattern with lines",
    template_geometric: "Geometric",
    template_geometric_desc: "Subtle geometric patterns",
    template_paper: "Paper",
    template_paper_desc: "Graph paper visual style",
    template_white: "White Background",
    template_white_desc: "White background with gray grid lines",
    apply_template: "Apply Template",
    
    // Messages
    character_added: "Character added successfully",
    event_added: "Event added successfully",
    period_added: "Period added successfully",
    event_updated: "Event updated successfully",
    event_removed: "Event removed successfully",
    timeline_saved: "Timeline saved successfully",
    timeline_loaded: "Timeline loaded successfully",
    all_locked: "All characters locked",
    all_unlocked: "All characters unlocked",
    character_locked: "locked",
    character_unlocked: "unlocked",
    flag_locked: "Flag locked",
    flag_unlocked: "Flag unlocked",
    template_applied: "applied successfully",
    generating_pdf: "Generating PDF...",
    pdf_generated: "PDF generated successfully",
    generating_image: "Generating image...",
    image_generated: "PNG image generated successfully",
    no_results: "No results found",
    
    // Validation
    title_required: "Title is required",
    start_date_required: "Start date is required and must be a number",
    end_date_required: "End date is required and must be a number",
    end_before_start: "End date cannot be before start date",
    year_required: "Year is required and must be a number",
    
    // Confirmations
    confirm_delete: "Are you sure you want to delete this item?",
    confirm_clear: "Are you sure you want to clear all data and load a new file? This action cannot be undone.",
    
    // Dates
    bc: "BC",
    ad: "AD",
    age_years: "years"
  },
  
  es: {
    // Títulos de página y modales
    page_title: "Línea de Tiempo Histórica",
    timeline_stats: "Estadísticas de la Línea de Tiempo",
    keyboard_shortcuts: "Atajos de Teclado",
    tutorial_title: "Tutorial: Cómo Usar la Línea de Tiempo",
    templates_title: "Plantillas para Línea de Tiempo",
    
    // Botones principales
    add_character: "Añadir Personaje",
    add_event: "Añadir Evento",
    add_period: "Añadir Período",
    settings: "Configuración",
    menu: "Menú",
    
    // Menú de configuración
    dark_mode: "Modo Oscuro",
    statistics: "Estadísticas",
    templates: "Plantillas",
    language: "Idioma",
    
    // Acciones de archivo
    load: "Cargar",
    save: "Guardar",
    export_png: "Exportar como PNG",
    export_pdf: "Exportar como PDF",
    help: "Ayuda",
    clear_all: "Limpiar Todo",
    
    // Formularios
    title: "Título",
    description: "Descripción",
    year_label: "Año (use - para a.C.)",
    event_color: "Color del Evento",
    character_color: "Color del Personaje",
    transparency: "Transparencia",
    character_period: "Personaje - Período del Personaje",
    start_date: "Fecha Inicial",
    end_date: "Fecha Final",
    until: "hasta",
    approximate_start: "Fecha inicial aproximada",
    approximate_end: "Fecha final aproximada",
    cancel: "Cancelar",
    confirm: "Confirmar",
    
    // Posicionamiento
    position_character: "¿Cómo desea posicionar el personaje?",
    auto_adjust: "Ajustar automáticamente",
    add_below: "Añadir debajo (mantener otros en la misma posición)",
    
    // Menú contextual
    edit: "Editar",
    lock_position: "Bloquear posición",
    unlock_position: "Desbloquear posición",
    delete: "Eliminar",
    
    // Búsqueda
    search_timeline: "Buscar en la línea de tiempo...",
    search: "Buscar",
    zoom_control: "Control de zoom",
    zoom: "Zoom",
    lock_unlock_all: "Bloquear/desbloquear todos los personajes",
    
    // Estadísticas
    total_events: "Total de Eventos",
    total_characters: "Total de Personajes",
    total_periods: "Total de Períodos",
    earliest_year: "Año Más Antiguo",
    latest_year: "Año Más Reciente",
    century_summary: "Resumen por Siglos",
    
    // Atajos de teclado
    add_event_shortcut: "Añadir evento",
    add_character_shortcut: "Añadir personaje",
    add_period_shortcut: "Añadir período",
    save_timeline_shortcut: "Guardar línea de tiempo",
    load_timeline_shortcut: "Cargar línea de tiempo",
    export_png_shortcut: "Exportar como PNG",
    export_pdf_shortcut: "Exportar como PDF",
    toggle_dark_mode_shortcut: "Alternar modo oscuro",
    open_help_shortcut: "Abrir ayuda",
    zoom_in_shortcut: "Aumentar zoom",
    zoom_out_shortcut: "Reducir zoom",
    navigate_left_shortcut: "Navegar a la izquierda",
    navigate_right_shortcut: "Navegar a la derecha",
    
    // Tutorial
    step_navigation_title: "Navegación Básica",
    step_navigation_desc: "Use el ratón para arrastrar la línea de tiempo horizontalmente. Mantenga Ctrl y use la rueda del ratón para acercar o alejar el zoom. Use las teclas + y - del teclado para ajustar el zoom rápidamente.",
    step_content_title: "Añadiendo Contenido",
    step_content_desc: "Use los botones en la barra superior derecha para añadir diferentes tipos de contenido:",
    character: "Personaje",
    character_desc: "Individuos con fechas de nacimiento y muerte",
    event: "Evento",
    event_desc: "Momentos específicos en el tiempo",
    period: "Período",
    period_desc: "Intervalos de tiempo con inicio y fin",
    step_customize_title: "Personalizando Eventos",
    step_customize_desc: "Haga clic derecho en cualquier evento o personaje para editar o eliminar. Puede personalizar colores y niveles de transparencia.",
    step_save_title: "Guardando y Compartiendo",
    step_save_desc: "Use el menú para guardar su línea de tiempo en formato JSON. También puede exportar como PNG para compartir o PDF para imprimir.",
    step_language_title: "Cambiando Idioma",
    step_language_desc: "Puede cambiar el idioma de la interfaz en cualquier momento haciendo clic en el icono de configuración y seleccionando \"Idioma\". La aplicación soporta portugués, inglés y español.",
    step_advanced_title: "Consejos Avanzados",
    step_advanced_desc: "Para mayor eficiencia, use los atajos de teclado listados en el panel \"Atajos de Teclado\". Los personajes pueden reordenarse verticalmente arrastrándolos hacia arriba o abajo.",
    step_lock_desc: "Para personajes, puede bloquear/desbloquear la posición haciendo clic derecho sobre ellos, o usar el botón de candado para bloquear/desbloquear todos a la vez.",
    
    // Plantillas
    template_default: "Predeterminado",
    template_default_desc: "Línea de tiempo clásica con todas las características",
    template_history: "Historia Mundial",
    template_history_desc: "Enfocado en eventos históricos importantes",
    template_biography: "Biografía",
    template_biography_desc: "Ideal para trazar vidas de personajes",
    template_project: "Proyecto",
    template_project_desc: "Para planificación e hitos de proyectos",
    template_science: "Ciencia",
    template_science_desc: "Descubrimientos y avances científicos",
    template_blueprint: "Plano",
    template_blueprint_desc: "Estilo cuadrícula con líneas verticales alineadas",
    template_dots: "Punteado",
    template_dots_desc: "Fondo con puntos y líneas verticales",
    template_waves: "Ondas",
    template_waves_desc: "Patrón de ondas suaves con líneas",
    template_geometric: "Geométrico",
    template_geometric_desc: "Patrones geométricos sutiles",
    template_paper: "Papel",
    template_paper_desc: "Estilo visual de papel milimetrado",
    template_white: "Fondo Blanco",
    template_white_desc: "Fondo blanco con líneas de cuadrícula grises",
    apply_template: "Aplicar Plantilla",
    
    // Mensajes
    character_added: "Personaje añadido exitosamente",
    event_added: "Evento añadido exitosamente",
    period_added: "Período añadido exitosamente",
    event_updated: "Evento actualizado exitosamente",
    event_removed: "Evento eliminado exitosamente",
    timeline_saved: "Línea de tiempo guardada exitosamente",
    timeline_loaded: "Línea de tiempo cargada exitosamente",
    all_locked: "Todos los personajes bloqueados",
    all_unlocked: "Todos los personajes desbloqueados",
    character_locked: "bloqueado",
    character_unlocked: "desbloqueado",
    flag_locked: "Flag bloqueada",
    flag_unlocked: "Flag desbloqueada",
    template_applied: "aplicado exitosamente",
    generating_pdf: "Generando PDF...",
    pdf_generated: "PDF generado exitosamente",
    generating_image: "Generando imagen...",
    image_generated: "Imagen PNG generada exitosamente",
    no_results: "No se encontraron resultados",
    
    // Validación
    title_required: "El título es obligatorio",
    start_date_required: "La fecha inicial es obligatoria y debe ser un número",
    end_date_required: "La fecha final es obligatoria y debe ser un número",
    end_before_start: "La fecha final no puede ser anterior a la fecha inicial",
    year_required: "El año es obligatorio y debe ser un número",
    
    // Confirmaciones
    confirm_delete: "¿Está seguro de que desea eliminar este elemento?",
    confirm_clear: "¿Está seguro de que desea limpiar todos los datos y cargar un nuevo archivo? Esta acción no se puede deshacer.",
    
    // Fechas
    bc: "a.C.",
    ad: "d.C.",
    age_years: "años"
  }
};

let currentLanguage = 'pt';

// Função para obter tradução
function t(key) {
  return translations[currentLanguage][key] || translations.pt[key] || key;
}

// Função para aplicar traduções
function applyTranslations() {
  // Atualizar título da página
  document.getElementById('page-title').textContent = t('page_title');
  document.title = t('page_title');
  
  // Atualizar elementos com data-i18n
  document.querySelectorAll('[data-i18n]').forEach(element => {
    const key = element.getAttribute('data-i18n');
    element.textContent = t(key);
  });
  
  // Atualizar atributos title
  document.querySelectorAll('[data-i18n-title]').forEach(element => {
    const key = element.getAttribute('data-i18n-title');
    element.title = t(key);
  });
  
  // Atualizar atributos aria-label
  document.querySelectorAll('[data-i18n-aria]').forEach(element => {
    const key = element.getAttribute('data-i18n-aria');
    element.setAttribute('aria-label', t(key));
  });
  
  // Atualizar placeholders
  document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
    const key = element.getAttribute('data-i18n-placeholder');
    element.placeholder = t(key);
  });
  
  // Atualizar idioma do HTML
  const langMap = { pt: 'pt-BR', en: 'en-US', es: 'es-ES' };
  document.documentElement.lang = langMap[currentLanguage] || 'pt-BR';
}

// Configuração do seletor de idioma
function setupLanguageSelector() {
  const languageModal = document.getElementById('language-modal');
  const languageOptions = document.querySelectorAll('.language-option');
  const languageConfirm = document.getElementById('language-confirm');
  
  // Verificar se já existe um idioma salvo ou definir português como padrão
  const savedLanguage = localStorage.getItem('language');
  if (savedLanguage && translations[savedLanguage]) {
    currentLanguage = savedLanguage;
  } else {
    // Definir português como padrão e salvar
    currentLanguage = 'pt';
    localStorage.setItem('language', 'pt');
  }
  
  // Sempre fechar o modal e aplicar traduções
  if (languageModal) {
    languageModal.classList.add('hidden');
  }
  applyTranslations();
  
  // Configurar seleção de idioma
  languageOptions.forEach(option => {
    option.addEventListener('click', () => {
      languageOptions.forEach(opt => opt.classList.remove('selected'));
      option.classList.add('selected');
    });
  });
  
  // Confirmar seleção de idioma
  if (languageConfirm) {
    languageConfirm.addEventListener('click', () => {
      const selectedOption = document.querySelector('.language-option.selected');
      if (selectedOption) {
        currentLanguage = selectedOption.dataset.lang;
        localStorage.setItem('language', currentLanguage);
        if (languageModal) {
          languageModal.classList.add('hidden');
        }
        applyTranslations();
        
        // Re-renderizar eventos para atualizar tooltips e conteúdos dinâmicos
        if (typeof renderEvents === 'function') {
          renderEvents();
        }
        
        // Atualizar estatísticas se o modal estiver aberto
        const statsModal = document.getElementById('stats-modal');
        if (statsModal && statsModal.classList.contains('active') && typeof updateStatistics === 'function') {
          updateStatistics();
        }
        
        // Forçar atualização do autocomplete se existir
        if (typeof setupAutoComplete === 'function') {
          setupAutoComplete();
        }
        
        // Atualizar marcadores de data se existir
        if (typeof createDateMarkers === 'function') {
          createDateMarkers();
        }
        
        // Forçar atualização de todos os elementos da interface
        setTimeout(() => {
          // Atualizar tooltips de eventos existentes
          document.querySelectorAll('.person-event .event-content').forEach(content => {
            const eventId = content.closest('.person-event').dataset.eventId;
            if (eventId !== undefined && events[eventId]) {
              const eventData = events[eventId];
              if (eventData.type === 'person') {
                let birthYearText = eventData.birthYear < 0 ? `${-eventData.birthYear} ${t('bc')}` : `${eventData.birthYear} ${t('ad')}`;
                if (eventData.birthYear === 0) birthYearText = "";
                let deathYearText = eventData.deathYear < 0 ? `${-eventData.deathYear} ${t('bc')}` : `${eventData.deathYear} ${t('ad')}`;
                if (eventData.deathYear === 0) deathYearText = "";
                
                let age;
                if (eventData.birthYear < 0 && eventData.deathYear > 0) {
                  age = eventData.deathYear - eventData.birthYear - 2;
                } else {
                  age = eventData.deathYear - eventData.birthYear;
                }
                
                const lockIconHtml = eventData.lockedPosition ? '<span class="lock-icon">🔒</span>' : '';
                
                content.innerHTML = `
                  <h4>${sanitizeHtml(eventData.title)}</h4>
                  <p>${eventData.impreciseBirth ? '(aprox.) ' : ''}${birthYearText} ${t('until')} ${eventData.impreciseDeath ? '(aprox.) ' : ''}${deathYearText}</p>
                  <p><strong>${age} ${t('age_years')}</strong> ${lockIconHtml}</p>
                `;
              }
            }
          });
          
          // Atualizar eventos tipo flag
          document.querySelectorAll('.event-flag .event-content').forEach(content => {
            const eventId = content.closest('.event-flag').dataset.eventId;
            if (eventId !== undefined && events[eventId]) {
              const eventData = events[eventId];
              if (eventData.type === 'event') {
                let yearText = eventData.year < 0 ? `${-eventData.year} ${t('bc')}` : `${eventData.year} ${t('ad')}`;
                if (eventData.year === 0) yearText = "";
                
                const lockIconHtml = eventData.lockedPosition ? '<span class="lock-icon">🔒</span>' : '';
                
                content.innerHTML = `
                  <h3>${yearText}</h3>
                  <h4>${sanitizeHtml(eventData.title)}</h4>
                  ${lockIconHtml ? `<p>${lockIconHtml}</p>` : ''}
                `;
              }
            }
          });
          
          // Atualizar marcadores de data
          document.querySelectorAll('.event-flag-line').forEach(line => {
            const eventId = line.closest('.event-flag').dataset.eventId;
            if (eventId !== undefined && events[eventId]) {
              const eventData = events[eventId];
              if (eventData.type === 'event') {
                let yearText = eventData.year < 0 ? `${-eventData.year} ${t('bc')}` : `${eventData.year} ${t('ad')}`;
                if (eventData.year === 0) yearText = "";
                line.dataset.year = yearText;
              }
            }
          });
          
          // Atualizar período tooltip
          document.querySelectorAll('.period-overlay').forEach(periodEl => {
            const eventId = parseInt(periodEl.dataset.eventId);
            const eventData = events[eventId];
            if (eventData && eventData.type === 'period') {
              // Força a regeneração do tooltip ao passar o mouse
              periodEl.addEventListener('mouseenter', function() {
                const periodDescriptionBox = document.getElementById('period-description-box');
                const periodTitleBox = document.getElementById('period-title');
                const periodYearsBox = document.getElementById('period-years');
                
                if (periodTitleBox) periodTitleBox.textContent = eventData.title;
                
                let startYearText = eventData.startYear < 0 ? `${-eventData.startYear} ${t('bc')}` : `${eventData.startYear} ${t('ad')}`;
                if (eventData.startYear === 0) startYearText = "";
                let endYearText = eventData.endYear < 0 ? `${-eventData.endYear} ${t('bc')}` : `${eventData.endYear} ${t('ad')}`;
                if (eventData.endYear === 0) endYearText = "";
                
                if (periodYearsBox) periodYearsBox.textContent = `${startYearText} ${t('until')} ${endYearText}`;
              });
            }
          });
          
        }, 100);
      }
    });
  }
}

document.addEventListener('DOMContentLoaded', function() {
    setupLanguageSelector();
    
    const timeline = document.querySelector('.timeline-horizontal');
    const addPersonBtn = document.querySelector('.add-person-btn');
    const addEventBtn = document.querySelector('.add-event-btn');
    const addPeriodBtn = document.querySelector('.add-period-btn');
    const settingsMainBtn = document.querySelector('.settings-main-btn');
    const settingsModal = document.getElementById('settings-modal');
    const settingsClose = document.querySelector('.settings-close');
    const darkModeToggle = document.getElementById('dark-mode-toggle');
    const viewStatsBtn = document.getElementById('view-stats-btn');
    const viewKeyboardBtn = document.getElementById('view-keyboard-btn');
    const loadTemplateBtn = document.getElementById('load-template-btn');
    const changeLanguageBtn = document.getElementById('change-language-btn');
    const exportPngBtn = document.getElementById('export-png-btn');
    const exportPdfBtn = document.getElementById('export-pdf-btn');
    const clearAllSettingsBtn = document.getElementById('clear-all-btn');
    const helpBtn = document.querySelector('.help-btn');
    const eventForm = document.querySelector('.event-form');
    const overlay = document.querySelector('.overlay');
    const saveBtn = document.querySelector('.form-save-btn');
    const cancelBtn = document.querySelector('.cancel-btn');
    const contextMenu = document.querySelector('.context-menu');
    const contextToggleLock = document.getElementById('context-toggle-lock');
    const menuBtn = document.querySelector('.menu-btn');
    const dropdown = document.querySelector('.dropdown-content');
    const lockAllBtn = document.getElementById('lock-all-btn');
    const positionDialog = document.getElementById('position-dialog');
    const positionDialogConfirm = document.getElementById('position-dialog-confirm');
    const backgroundGrid = document.getElementById('background-grid');
    const zoomControl = document.querySelector('.zoom-control-horizontal');
    const zoomIcon = document.querySelector('.zoom-icon');
    const searchContainer = document.querySelector('.search-container');
    const searchIcon = document.querySelector('.search-icon');
    let selectedEventElement = null;
    let allPersonsLocked = false;
    let tempNewPersonData = null;

    const characterDescriptionPopup = document.getElementById('character-description-popup');
    const characterPopupDescriptionText = document.getElementById('character-popup-description-text');

    // Caixa de descrição para períodos
    const periodDescriptionBox = document.getElementById('period-description-box');
    const periodTitleBox = document.getElementById('period-title');
    const periodYearsBox = document.getElementById('period-years');
    const periodDescBox = document.getElementById('period-description');

    // Elementos de busca
    const searchInput = document.querySelector('.search-input');
    const searchButton = document.querySelector('.search-button');
    const searchResults = document.querySelector('.search-results');
    const searchAutocomplete = document.querySelector('.search-autocomplete');

    // Elementos dos modais
    const statsModal = document.getElementById('stats-modal');
    const keyboardModal = document.getElementById('keyboard-modal');
    const tutorialModal = document.getElementById('tutorial-modal');
    const templatesModal = document.getElementById('templates-modal');
    const modalCloseButtons = document.querySelectorAll('.close-modal');
    
    // Mobile UI helpers
    let zoomControlVisible = false;
    let searchControlVisible = false;
    
    // Configuração do controle de zoom para mobile
    if (zoomIcon) {
        zoomIcon.addEventListener('click', function() {
            if (zoomControlVisible) {
                zoomControl.classList.remove('mobile-expanded');
                zoomControlVisible = false;
            } else {
                zoomControl.classList.add('mobile-expanded');
                zoomControlVisible = true;
                // Esconder a busca se estiver aberta
                if (searchControlVisible) {
                    searchContainer.classList.remove('mobile-expanded');
                    searchControlVisible = false;
                }
            }
        });
    }
    
    // Configuração do controle de busca para mobile
    if (searchIcon) {
        searchIcon.addEventListener('click', function() {
            if (searchControlVisible) {
                searchContainer.classList.remove('mobile-expanded');
                searchControlVisible = false;
            } else {
                searchContainer.classList.add('mobile-expanded');
                searchControlVisible = true;
                // Esconder o zoom se estiver aberto
                if (zoomControlVisible) {
                    zoomControl.classList.remove('mobile-expanded');
                    zoomControlVisible = false;
                }
            }
        });
    }
    
    // Fechar os controles mobile quando clicar fora deles
    document.addEventListener('click', function(e) {
        if (zoomControlVisible && !zoomControl.contains(e.target) && !zoomIcon.contains(e.target)) {
            zoomControl.classList.remove('mobile-expanded');
            zoomControlVisible = false;
        }
        
        if (searchControlVisible && !searchContainer.contains(e.target) && !searchIcon.contains(e.target)) {
            searchContainer.classList.remove('mobile-expanded');
            searchControlVisible = false;
        }
    });
    
    // Templates
    let templates = {
        default: {
            name: "Padrão",
            primaryColor: "#2196f3",
            secondaryColor: "#1565C0",
            eventColor: "#4676E0",
            personColor: "#4676E0",
            periodColor: "#4676E0",
            bgClass: "",
            gridLineColor: "rgba(0,0,0,0.05)"
        },
        history: {
            name: "História Mundial",
            primaryColor: "#8C6E63",
            secondaryColor: "#5D4037",
            eventColor: "#8C6E63",
            personColor: "#795548",
            periodColor: "#A1887F",
            bgClass: "",
            gridLineColor: "rgba(0,0,0,0.05)"
        },
        biography: {
            name: "Biografia",
            primaryColor: "#4CAF50",
            secondaryColor: "#388E3C",
            eventColor: "#66BB6A",
            personColor: "#4CAF50",
            periodColor: "#81C784",
            bgClass: "",
            gridLineColor: "rgba(0,0,0,0.05)"
        },
        project: {
            name: "Projeto",
            primaryColor: "#FF5722",
            secondaryColor: "#E64A19",
            eventColor: "#FF7043",
            personColor: "#FF5722",
            periodColor: "#FFAB91",
            bgClass: "",
            gridLineColor: "rgba(255, 87, 34, 0.15)",
            showVerticalLines: true
        },
        science: {
            name: "Ciência",
            primaryColor: "#2196F3",
            secondaryColor: "#1976D2",
            eventColor: "#42A5F5",
            personColor: "#2196F3",
            periodColor: "#90CAF9",
            bgClass: "",
            gridLineColor: "rgba(0,0,0,0.05)"
        },
        blueprint: {
            name: "Blueprint",
            primaryColor: "#3F51B5",
            secondaryColor: "#303F9F",
            eventColor: "#3F51B5",
            personColor: "#5C6BC0",
            periodColor: "#7986CB",
            bgClass: "blueprint-bg",
            gridLineColor: "rgba(63, 81, 181, 0.15)",
            showVerticalLines: true
        },
        dots: {
            name: "Pontilhado",
            primaryColor: "#9C27B0",
            secondaryColor: "#7B1FA2",
            eventColor: "#9C27B0",
            personColor: "#AB47BC",
            periodColor: "#CE93D8",
            bgClass: "dots-bg",
            gridLineColor: "rgba(156, 39, 176, 0.12)",
            showVerticalLines: true
        },
        waves: {
            name: "Ondas",
            primaryColor: "#FF9800",
            secondaryColor: "#F57C00",
            eventColor: "#FF9800",
            personColor: "#FFB74D",
            periodColor: "#FFCC80",
            bgClass: "waves-bg",
            gridLineColor: "rgba(255, 152, 0, 0.12)",
            showVerticalLines: true
        },
        geometric: {
            name: "Geométrico",
            primaryColor: "#607D8B",
            secondaryColor: "#455A64",
            eventColor: "#607D8B",
            personColor: "#78909C",
            periodColor: "#90A4AE",
            bgClass: "geometric-bg",
            gridLineColor: "rgba(96, 125, 139, 0.08)"
        },
        paper: {
            name: "Papel",
            primaryColor: "#795548",
            secondaryColor: "#5D4037",
            eventColor: "#795548",
            personColor: "#8D6E63",
            periodColor: "#A1887F",
            bgClass: "paper-bg",
            gridLineColor: "rgba(121, 85, 72, 0.1)"
        },
        white: {
            name: "Fundo Branco",
            primaryColor: "#666666",
            secondaryColor: "#444444",
            eventColor: "#666666",
            personColor: "#666666",
            periodColor: "#888888",
            bgClass: "white-bg",
            gridLineColor: "rgba(128, 128, 128, 0.2)",
            showVerticalLines: true
        }
    };

    // Função para travar/destravar todos os personagens
    if (lockAllBtn) {
        lockAllBtn.addEventListener('click', function() {
            allPersonsLocked = !allPersonsLocked;
            
            // Atualiza o ícone do botão
            if (allPersonsLocked) {
                lockAllBtn.innerHTML = `
                    <svg viewBox="0 0 24 24" width="20" height="20">
                        <path fill="currentColor" d="M12,17A2,2 0 0,0 14,15C14,13.89 13.1,13 12,13A2,2 0 0,0 10,15A2,2 0 0,0 12,17M18,8A2,2 0 0,1 20,10V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V10A2,2 0 0,1 6,8H7V6A5,5 0 0,1 12,1A5,5 0 0,1 17,6V8H18M12,3A3,3 0 0,0 9,6V8H15V6A3,3 0 0,0 12,3Z" />
                    </svg>
                `;
            } else {
                lockAllBtn.innerHTML = `
                    <svg viewBox="0 0 24 24" width="20" height="20">
                        <path fill="currentColor" d="M18,8A2,2 0 0,1 20,10V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V10A2,2 0 0,1 6,8H15V6A3,3 0 0,0 12,3A3,3 0 0,0 9,6H7A5,5 0 0,1 12,1A5,5 0 0,1 17,6V8H18M12,17A2,2 0 0,0 14,15A2,2 0 0,0 12,13A2,2 0 0,0 10,15A2,2 0 0,0 12,17Z" />
                    </svg>
                `;
            }
            
            // Atualiza os personagens
            events.forEach(event => {
                if (event.type === 'person') {
                    event.lockedPosition = allPersonsLocked;
                }
            });
            
            // Renderiza para aplicar as alterações, mas sem recalcular posições automaticamente
            renderEvents(true);
            showToast(allPersonsLocked ? t('all_locked') : t('all_unlocked'));
        });
    }

    // Configuração da janela de configurações
    if (settingsMainBtn && settingsModal) {
        settingsMainBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            settingsModal.classList.add('active');
            // Fechar dropdown do menu
            document.querySelector('.action-buttons').classList.remove('active');
        });
    }

    // Fechar janela de configurações
    if (settingsClose) {
        settingsClose.addEventListener('click', () => {
            settingsModal.classList.remove('active');
        });
    }

    // Fechar janela clicando fora dela
    if (settingsModal) {
        settingsModal.addEventListener('click', (e) => {
            if (e.target === settingsModal) {
                settingsModal.classList.remove('active');
            }
        });
    }

    // Configuração dos modais
    modalCloseButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            if (statsModal) statsModal.classList.remove('active');
            if (keyboardModal) keyboardModal.classList.remove('active');
            if (tutorialModal) tutorialModal.classList.remove('active');
            if (templatesModal) templatesModal.classList.remove('active');
            overlay.classList.remove('active');
        });
    });
    
    // Dialog de confirmação de posicionamento
    if (positionDialogConfirm) {
        positionDialogConfirm.addEventListener('click', function() {
            const positionType = document.querySelector('input[name="position-dialog"]:checked').value;
            
            if (!tempNewPersonData) return;
            
            // Adicionar a informação de posicionamento
            if (positionType === 'below') {
                // Encontrar a linha mais alta ocupada atual
                let highestRow = 0;
                events.forEach(event => {
                    if (event.type === 'person' && typeof event.personRow === 'number') {
                        highestRow = Math.max(highestRow, event.personRow);
                    }
                });
                
                // Colocar o novo personagem abaixo dos existentes
                tempNewPersonData.personRow = highestRow + 1;
            }
            
            events.push(tempNewPersonData);
            window.events = events;
            renderEvents();
            showToast(t('character_added'));
            
            // Otimizaรงรฃo: Debouncing para salvamento automรกtico
            clearTimeout(window.autoSaveTimeout);
            window.autoSaveTimeout = setTimeout(() => {
                localStorage.setItem('timelineData', JSON.stringify({ events: window.events, zoom: currentZoom }));
            }, 500);
            
            // Limpa dados temporários e fecha o diálogo
            tempNewPersonData = null;
            positionDialog.style.display = 'none';
            overlay.classList.remove('active');
        });
    }
    
    // Selecionar template
    document.querySelectorAll('.template-item').forEach(item => {
        item.addEventListener('click', () => {
            document.querySelectorAll('.template-item').forEach(t => t.classList.remove('active'));
            item.classList.add('active');
        });
    });
    
    // Aplicar template
    const applyTemplateBtn = document.getElementById('apply-template');
    if (applyTemplateBtn) {
        applyTemplateBtn.addEventListener('click', () => {
            const selectedTemplate = document.querySelector('.template-item.active').dataset.template;
            const showGrid = document.querySelector('.template-item.active').dataset.showGrid === 'true';
            const template = templates[selectedTemplate];
            
            if (template) {
                // Aplicar cores
                document.documentElement.style.setProperty('--primary-color', template.primaryColor);
                document.documentElement.style.setProperty('--primary-dark', template.secondaryColor);
                document.documentElement.style.setProperty('--grid-line-color', template.gridLineColor);
                
                // Aplicar classes de fundo
                document.body.classList.remove('academic-bg', 'night-bg', 'minimal-bg', 'retro-bg', 'blueprint-bg', 'dots-bg', 'waves-bg', 'geometric-bg', 'paper-bg', 'white-bg');
                if (template.bgClass) {
                    document.body.classList.add(template.bgClass);
                }
                
                // Definir se as linhas verticais devem ser mostradas
                if (showGrid) {
                    document.body.classList.add('show-vertical-lines');
                } else {
                    document.body.classList.remove('show-vertical-lines');
                }
                
                // Atualizar linhas de grade vertical se existirem
                createVerticalGridLines();
                
                // Salva as configurações
                localStorage.setItem('primaryColor', template.primaryColor);
                localStorage.setItem('secondaryColor', template.secondaryColor);
                localStorage.setItem('selectedTemplate', selectedTemplate);
                localStorage.setItem('templateBgClass', template.bgClass || '');
                localStorage.setItem('gridLineColor', template.gridLineColor);
                localStorage.setItem('showVerticalLines', showGrid.toString());
                
                showToast(`${t('templates')} "${template.name}" ${t('template_applied')}`);
                
                // Fecha o modal
                templatesModal.classList.remove('active');
                overlay.classList.remove('active');
            }
        });
    }
    
    // Criar linhas de grade vertical
    function createVerticalGridLines() {
        // Limpar grade existente
        if (backgroundGrid) {
            backgroundGrid.innerHTML = '';
            
            // Criar linhas verticais alinhadas com os marcadores de data
            const dateMarkers = document.querySelectorAll('.date-marker');
            const minorTicks = document.querySelectorAll('.minor-tick');
            
            // Adicionar linhas para marcadores principais
            dateMarkers.forEach(marker => {
                const left = marker.style.left;
                const line = document.createElement('div');
                line.className = 'vertical-grid-line';
                line.style.left = left;
                backgroundGrid.appendChild(line);
            });
            
            // Adicionar linhas mais finas para marcadores secundários
            minorTicks.forEach(tick => {
                const left = tick.style.left;
                const line = document.createElement('div');
                line.className = 'vertical-grid-line';
                line.style.left = left;
                line.style.opacity = '0.5';
                backgroundGrid.appendChild(line);
            });
        }
    }

    // Toggle do modo escuro na janela de configurações
    if (darkModeToggle) {
        // Inicializar estado do toggle baseado no modo atual
        if (document.documentElement.classList.contains('dark')) {
            darkModeToggle.classList.add('active');
        }
        
        darkModeToggle.addEventListener('click', () => {
            document.documentElement.classList.toggle('dark');
            darkModeToggle.classList.toggle('active');
            localStorage.setItem('darkMode', document.documentElement.classList.contains('dark'));
        });
    }

    if (viewStatsBtn) {
        viewStatsBtn.addEventListener('click', () => {
            updateStatistics();
            statsModal.classList.add('active');
            overlay.classList.add('active');
            settingsModal.classList.remove('active');
        });
    }

    if (viewKeyboardBtn) {
        viewKeyboardBtn.addEventListener('click', () => {
            keyboardModal.classList.add('active');
            overlay.classList.add('active');
            settingsModal.classList.remove('active');
        });
    }

    if (loadTemplateBtn) {
        loadTemplateBtn.addEventListener('click', () => {
            // Atualiza o template selecionado
            const savedTemplate = localStorage.getItem('selectedTemplate') || 'default';
            document.querySelectorAll('.template-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.template === savedTemplate) {
                    item.classList.add('active');
                }
            });
            
            templatesModal.classList.add('active');
            overlay.classList.add('active');
            settingsModal.classList.remove('active');
        });
    }
    
    // Botão de idioma na janela de configurações
    if (changeLanguageBtn) {
        changeLanguageBtn.addEventListener('click', () => {
            const languageModal = document.getElementById('language-modal');
            if (languageModal) {
                languageModal.classList.remove('hidden');
                settingsModal.classList.remove('active');
            }
        });
    }
    
    // Botão exportar PNG na janela de configurações
    if (exportPngBtn) {
        exportPngBtn.addEventListener('click', () => {
            exportToPNG();
            settingsModal.classList.remove('active');
        });
    }
    
    // Botão exportar PDF na janela de configurações
    if (exportPdfBtn) {
        exportPdfBtn.addEventListener('click', () => {
            exportToPDF();
            settingsModal.classList.remove('active');
        });
    }
    
    // Botão limpar tudo na janela de configurações
    if (clearAllSettingsBtn) {
        clearAllSettingsBtn.addEventListener('click', () => {
            if (confirm(t('confirm_clear_all') || 'Tem certeza que deseja limpar toda a linha do tempo?')) {
                clearTimeline();
                settingsModal.classList.remove('active');
            }
        });
    }
    
    // Função para limpar toda a timeline
    function clearTimeline() {
        window.events = events = [];
        localStorage.removeItem('timelineData');
        renderEvents();
        const fileInput = document.querySelector('input[type="file"]');
        if (fileInput) {
            fileInput.value = null;
        }
        showToast(t('timeline_cleared') || 'Linha do tempo limpa');
    }

    if (helpBtn) {
        helpBtn.addEventListener('click', () => {
            tutorialModal.classList.add('active');
            overlay.classList.add('active');
        });
    }
    
    // Mostrar tutorial na primeira visita
    if (!localStorage.getItem('tutorialShown')) {
        setTimeout(() => {
            tutorialModal.classList.add('active');
            overlay.classList.add('active');
            localStorage.setItem('tutorialShown', 'true');
        }, 1000);
    }
    
    // Função de exibição de toasts para notificações
    function showToast(message, type = 'info') {
        const toastContainer = document.querySelector('.toast-container');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;
        toastContainer.appendChild(toast);
        
        setTimeout(() => {
            toast.remove();
        }, 3000);
    }
    
    // Configuração para modo escuro
    function setupDarkMode() {
        // Verifica se há preferência salva no localStorage
        const savedDarkMode = localStorage.getItem('darkMode');
        if (savedDarkMode === 'true') {
            document.documentElement.classList.add('dark');
        }
        
        // Verifica preferência do sistema
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches && savedDarkMode !== 'false') {
            document.documentElement.classList.add('dark');
        }
        
        // Listener para mudanças na preferência do sistema
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches && localStorage.getItem('darkMode') !== 'false') {
                document.documentElement.classList.add('dark');
            } else if (!event.matches && localStorage.getItem('darkMode') !== 'true') {
                document.documentElement.classList.remove('dark');
            }
        });
        
        // Carregar cores personalizadas
        const savedPrimaryColor = localStorage.getItem('primaryColor');
        const savedSecondaryColor = localStorage.getItem('secondaryColor');
        const savedGridLineColor = localStorage.getItem('gridLineColor');
        const savedBgClass = localStorage.getItem('templateBgClass');
        const showVerticalLines = localStorage.getItem('showVerticalLines') === 'true';
        
        if (savedPrimaryColor) {
            document.documentElement.style.setProperty('--primary-color', savedPrimaryColor);
        }
        
        if (savedSecondaryColor) {
            document.documentElement.style.setProperty('--primary-dark', savedSecondaryColor);
        }
        
        if (savedGridLineColor) {
            document.documentElement.style.setProperty('--grid-line-color', savedGridLineColor);
        }
        
        if (savedBgClass) {
            document.body.classList.add(savedBgClass);
        }
        
        if (showVerticalLines) {
            document.body.classList.add('show-vertical-lines');
        } else {
            document.body.classList.remove('show-vertical-lines');
        }
    }
    
    setupDarkMode();
    
    // Busca na linha do tempo com autocomplete
    function setupSearchAutocomplete() {
        if (!searchInput || !searchAutocomplete) return;
        
        // Limpa qualquer seleção atual no autocomplete
        searchInput.addEventListener('focus', () => {
            if (searchAutocomplete) {
                searchAutocomplete.classList.add('active');
                updateSearchSuggestions();
            }
        });
        
        // Atualiza as sugestões quando o usuário digita
        // Otimizaรงรฃo: Debouncing para busca
        let searchTimeout;
        searchInput.addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => updateSearchSuggestions(e), 300);
        });
        
        // Fecha o autocomplete quando clica fora
        document.addEventListener('click', (e) => {
            if (!searchInput.contains(e.target) && !searchAutocomplete.contains(e.target)) {
                searchAutocomplete.classList.remove('active');
            }
        });

        
        // Teclas de navegação no autocomplete
        searchInput.addEventListener('keydown', (e) => {
            const suggestions = searchAutocomplete.querySelectorAll('.search-suggestion');
            if (!suggestions.length) return;
            
            let selected = searchAutocomplete.querySelector('.selected');
            let index = Array.from(suggestions).indexOf(selected);
            
            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    if (selected) {
                        selected.classList.remove('selected');
                        index = (index + 1) % suggestions.length;
                    } else {
                        index = 0;
                    }
                    suggestions[index].classList.add('selected');
                    break;
                    
                case 'ArrowUp':
                    e.preventDefault();
                    if (selected) {
                        selected.classList.remove('selected');
                        index = (index - 1 + suggestions.length) % suggestions.length;
                    } else {
                        index = suggestions.length - 1;
                    }
                    suggestions[index].classList.add('selected');
                    break;
                    
                case 'Enter':
                    if (selected) {
                        e.preventDefault();
                        const eventIndex = selected.dataset.eventIndex;
                        if (eventIndex !== undefined) {
                            scrollToEvent(parseInt(eventIndex));
                            searchAutocomplete.classList.remove('active');
                        }
                    } else {
                        performSearch();
                    }
                    break;
                    
                case 'Escape':
                    searchAutocomplete.classList.remove('active');
                    break;
            }
        });
    }
    
    function updateSearchSuggestions() {
        if (!searchInput || !searchAutocomplete) return;
        
        const searchTerm = searchInput.value.toLowerCase().trim();
        
        if (!searchTerm) {
            searchAutocomplete.innerHTML = '';
            return;
        }
        
        // Encontrar eventos correspondentes
        const matchingEvents = events.filter(event => 
            (event.title && event.title.toLowerCase().includes(searchTerm)) || 
            (event.description && event.description.toLowerCase().includes(searchTerm))
        ).slice(0, 5); // Limita a 5 resultados para não sobrecarregar
        
        if (matchingEvents.length === 0) {
            searchAutocomplete.innerHTML = `<div class="search-suggestion" style="font-style: italic; opacity: 0.7;">${t('no_results')}</div>`;
            return;
        }
        
        // Constrói as sugestões
        let suggestionsHTML = '';
        matchingEvents.forEach(event => {
            let infoText = '';
            
            if (event.type === 'event') {
                infoText = formatYear(event.year);
            } else if (event.type === 'person') {
                infoText = `${formatYear(event.birthYear)} - ${formatYear(event.deathYear)}`;
            } else if (event.type === 'period') {
                infoText = `${formatYear(event.startYear)} - ${formatYear(event.endYear)}`;
            }
            
            suggestionsHTML += `
                <div class="search-suggestion" data-event-index="${events.indexOf(event)}">
                    <div class="search-suggestion-title">${sanitizeHtml(event.title)}</div>
                    <div class="search-suggestion-info">${infoText}</div>
                </div>
            `;
        });
        
        searchAutocomplete.innerHTML = suggestionsHTML;
        
        // Mostrar o autocomplete se houver sugestões
        if (suggestionsHTML.trim()) {
            searchAutocomplete.classList.add('active');
        }
        
        // Adiciona event listeners para clicar nas sugestões
        document.querySelectorAll('.search-suggestion').forEach(suggestion => {
            suggestion.addEventListener('click', () => {
                const eventIndex = suggestion.dataset.eventIndex;
                if (eventIndex !== undefined) {
                    scrollToEvent(parseInt(eventIndex));
                    searchAutocomplete.classList.remove('active');
                }
            });
        });
    }
    
    function performSearch() {
        if (!searchInput || !searchResults) return;
        
        const searchTerm = searchInput.value.toLowerCase().trim();
        if (!searchTerm) {
            searchResults.classList.remove('active');
            return;
        }
        
        const results = events.filter(event => 
            (event.title && event.title.toLowerCase().includes(searchTerm)) || 
            (event.description && event.description.toLowerCase().includes(searchTerm))
        );
        
        if (results.length === 0) {
            searchResults.innerHTML = `<div class="search-result-item">${t('no_results')}</div>`;
            searchResults.classList.add('active');
            return;
        }
        
        let resultsHTML = '';
        results.forEach((result, index) => {
            let yearText = '';
            
            if (result.type === 'event') {
                yearText = formatYear(result.year);
            } else if (result.type === 'person') {
                yearText = `${formatYear(result.birthYear)} - ${formatYear(result.deathYear)}`;
            } else if (result.type === 'period') {
                yearText = `${formatYear(result.startYear)} - ${formatYear(result.endYear)}`;
            }
            
            resultsHTML += `
                <div class="search-result-item" data-event-index="${events.indexOf(result)}">
                    <div class="search-result-title">${sanitizeHtml(result.title)}</div>
                    <div class="search-result-year">${yearText}</div>
                </div>
            `;
        });
        
        searchResults.innerHTML = resultsHTML;
        searchResults.classList.add('active');
        
        // Adicionar event listeners para cada resultado
        document.querySelectorAll('.search-result-item').forEach(item => {
            item.addEventListener('click', () => {
                const eventIndex = item.dataset.eventIndex;
                if (eventIndex !== undefined) {
                    scrollToEvent(parseInt(eventIndex));
                    searchResults.classList.remove('active');
                }
            });
        });
    }
    
    function formatYear(year) {
        if (!year && year !== 0) return '';
        if (year < 0) return `${-year} ${t('bc')}`;
        if (year === 0) return "";
        return `${year} ${t('ad')}`;
    }
    
    function scrollToEvent(eventIndex) {
        const event = events[eventIndex];
        if (!event) return;
        
        let position;
        if (event.type === 'event') {
            position = ((event.year - absoluteMinYear) / totalRange) * 100;
        } else if (event.type === 'person') {
            position = ((event.birthYear - absoluteMinYear) / totalRange) * 100;
        } else if (event.type === 'period') {
            position = ((event.startYear - absoluteMinYear) / totalRange) * 100;
        }
        
        const timelineWidth = timeline.offsetWidth;
        const containerWidth = timelineContainer.offsetWidth;
        const scrollTo = (timelineWidth * position / 100) - (containerWidth / 2);
        
        timelineContainer.scrollTo({
            left: scrollTo,
            behavior: 'smooth'
        });
        
        // Destaca o elemento encontrado
        setTimeout(() => {
            const eventElement = document.querySelector(`.event[data-event-id="${eventIndex}"]`);
            if (eventElement) {
                eventElement.classList.add('highlighted');
                setTimeout(() => {
                    eventElement.classList.remove('highlighted');
                }, 2000);
            }
        }, 500);
    }
    
    // Função para sanitizar HTML (prevenir XSS)
    function sanitizeHtml(text) {
        const temp = document.createElement('div');
        temp.textContent = text;
        return temp.innerHTML;
    }

    // Validação de formulário aprimorada
    function validateForm(type) {
        const errorElement = document.getElementById('form-error');
        if (errorElement) {
            errorElement.style.display = 'none';
        }
        
        const title = document.getElementById('event-title').value.trim();
        if (!title) {
            showFormError(t('title_required'));
            return false;
        }
        
        if (type === 'person') {
            const birthYear = document.getElementById('birth-year').value;
            const deathYear = document.getElementById('death-year').value;
            
            if (!birthYear || isNaN(parseInt(birthYear))) {
                showFormError(t('start_date_required'));
                return false;
            }
            
            if (!deathYear || isNaN(parseInt(deathYear))) {
                showFormError(t('end_date_required'));
                return false;
            }
            
            const birthYearNum = parseInt(birthYear);
            const deathYearNum = parseInt(deathYear);
            
            if (deathYearNum < birthYearNum && !(birthYearNum < 0 && deathYearNum > 0)) {
                showFormError(t('end_before_start'));
                return false;
            }
        } else if (type === 'period') {
            const startYear = document.getElementById('period-start').value;
            const endYear = document.getElementById('period-end').value;
            
            if (!startYear || isNaN(parseInt(startYear))) {
                showFormError(t('start_date_required'));
                return false;
            }
            
            if (!endYear || isNaN(parseInt(endYear))) {
                showFormError(t('end_date_required'));
                return false;
            }
            
            const startYearNum = parseInt(startYear);
            const endYearNum = parseInt(endYear);
            
            if (endYearNum < startYearNum && !(startYearNum < 0 && endYearNum > 0)) {
                showFormError(t('end_before_start'));
                return false;
            }
        } else {
            const year = document.getElementById('event-year').value;
            
            if (!year || isNaN(parseInt(year))) {
                showFormError(t('year_required'));
                return false;
            }
        }
        
        return true;
    }
    
    function showFormError(message) {
        const errorElement = document.getElementById('form-error');
        if (errorElement) {
            errorElement.textContent = message;
            errorElement.style.display = 'block';
        }
    }

    let events = [];
    const zoomSlider = document.querySelector('.zoom-control-horizontal .zoom-slider');
    const zoomLabel = document.querySelector('.zoom-control-horizontal .zoom-percentage');
    let currentZoom = 0;
    
    // Constantes globais para cálculos de posicionamento
    const absoluteMinYear = -4500;
    const absoluteMaxYear = 2100;
    const totalRange = absoluteMaxYear - absoluteMinYear;
    const MIN_ZOOM = 0;
    const MAX_ZOOM = 100;

    window.events = events;
    window.currentZoom = currentZoom;

    // Carrega dados do localStorage
    const savedData = localStorage.getItem('timelineData');
    if (savedData) {
        try {
            const timelineData = JSON.parse(savedData);
            window.events = events = timelineData.events || [];
            window.currentZoom = currentZoom = timelineData.zoom || 0;
            if (zoomSlider) zoomSlider.value = currentZoom;
            if (zoomLabel) zoomLabel.textContent = currentZoom + '%';
            renderEvents();
        } catch (e) {
            console.error("Erro ao carregar dados do localStorage:", e);
            showToast("Erro ao carregar dados: " + e.message, "error");
            localStorage.removeItem('timelineData');
        }
    }

    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.json';
    fileInput.style.display = 'none';
    document.body.appendChild(fileInput);

    const loadBtn = document.querySelector('.load-btn');
    if (loadBtn) {
        loadBtn.addEventListener('click', () => {
            fileInput.value = null;
            fileInput.click();
        });
    }

    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (eventReader) => {
                try {
                    const timelineData = JSON.parse(eventReader.target.result);
                    window.events = events = timelineData.events || [];
                    window.currentZoom = currentZoom = timelineData.zoom || 0;
                    if (zoomSlider) zoomSlider.value = currentZoom;
                    if (zoomLabel) zoomLabel.textContent = currentZoom + '%';
                    renderEvents();
                    showToast(t('timeline_loaded'));
                } catch (error) {
                    showToast("Erro ao carregar arquivo JSON: " + error.message, "error");
                    console.error(error);
                } finally {
                    fileInput.value = null;
                }
            };
            reader.readAsText(file);
        } else {
            fileInput.value = null;
        }
    });

    let isDraggingHorizontal = false;
    let startX_timeline;
    let scrollLeftTimeline;
    const timelineContainer = document.getElementById('timeline-container');

    if (timelineContainer) {
        timelineContainer.addEventListener('mousedown', (e) => {
            if (e.target.closest('.person-event[data-is-being-dragged="true"]') || 
                e.target.closest('.event-flag[data-is-being-dragged="true"]')) return;
             if ((e.target.closest('.person-event') || e.target.closest('.event-flag')) && e.button === 0) {
                // Permite arrastar se o clique não for no event-content (tooltip) do personagem
                if (e.target.closest('.event-content')) return;
            }
            isDraggingHorizontal = true;
            timelineContainer.style.cursor = 'grabbing';
            startX_timeline = e.pageX - timelineContainer.offsetLeft;
            scrollLeftTimeline = timelineContainer.scrollLeft;
        });
        timelineContainer.addEventListener('mouseleave', () => {
            if (isDraggingHorizontal) {
                isDraggingHorizontal = false;
                timelineContainer.style.cursor = 'grab';
            }
        });
        timelineContainer.addEventListener('mouseup', () => {
            if (isDraggingHorizontal) {
                isDraggingHorizontal = false;
                timelineContainer.style.cursor = 'grab';
            }
        });
        timelineContainer.addEventListener('mousemove', (e) => {
            if (!isDraggingHorizontal) return;
            e.preventDefault();
            const x = e.pageX - timelineContainer.offsetLeft;
            const walk = (x - startX_timeline) * 2;
            timelineContainer.scrollLeft = scrollLeftTimeline - walk;
        });
        
        // NOVO SISTEMA DE ZOOM COM CENTRALIZAÇÃO
        timelineContainer.addEventListener('wheel', (e) => {
            if (e.ctrlKey) {
                e.preventDefault();
                
                // Capturar posição antes do zoom
                const scrollLeft = timelineContainer.scrollLeft;
                const containerWidth = timelineContainer.offsetWidth;
                const currentTimelineWidth = timeline.offsetWidth;
                const currentScrollRatio = currentTimelineWidth > 0 ? scrollLeft / (currentTimelineWidth - containerWidth) : 0;
                
                const delta = e.deltaY > 0 ? -2 : 2;
                let newZoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, currentZoom + delta));
                if (zoomSlider) zoomSlider.value = newZoom;
                window.currentZoom = currentZoom = newZoom;
                if (zoomLabel) zoomLabel.textContent = Math.round(newZoom) + '%';
                
                // Aplicar novo zoom
                const zoomFactor = 1 + (currentZoom / 100) * 29; // De 1x a 20x para dar mais espaço
                const baseWidth = 100;
                timeline.style.width = `${baseWidth * zoomFactor}%`;
                
                // Reposicionar eventos
                updateEventsPosition();
                
                // Recriar marcadores
                createDateMarkers();
                
                // Manter centralização após zoom
                setTimeout(() => {
                    const newTimelineWidth = timeline.offsetWidth;
                    const newScrollLeft = Math.max(0, currentScrollRatio * (newTimelineWidth - containerWidth));
                    timelineContainer.scrollLeft = newScrollLeft;
                }, 10);
                
                // Atualizar período overlays
                // Event listeners jรก estรฃo delegados no container principal
                
                createVerticalGridLines();
            }
        });
    }

    // Função para atualizar posições dos eventos após zoom
    function updateEventsPosition() {
        const eventElements = document.querySelectorAll('.event');
        
        eventElements.forEach(eventEl => {
            const eventId = eventEl.dataset.eventId;
            if (eventId === undefined) return;
            const eventData = events[parseInt(eventId)];
            if (!eventData) return;
            
            if (eventData.type === 'person') {
                const startPos = ((eventData.birthYear - absoluteMinYear) / totalRange) * 100;
                const endPos = ((eventData.deathYear - absoluteMinYear) / totalRange) * 100;
                let widthPercent = endPos - startPos;
                
                eventEl.style.left = `${startPos}%`;
                eventEl.style.width = `${widthPercent}%`;
                adjustPersonBarWidth(eventEl);
            } else if (eventData.type === 'period') {
                const startPos = ((eventData.startYear - absoluteMinYear) / totalRange) * 100;
                const endPos = ((eventData.endYear - absoluteMinYear) / totalRange) * 100;
                const periodWidth = endPos - startPos;
                
                eventEl.style.left = `${startPos}%`;
                
                // Garantir largura mínima visível para períodos curtos
                if (periodWidth < 0.3) {
                    eventEl.style.width = '10px';
                    eventEl.style.marginLeft = '-5px';
                } else {
                    eventEl.style.width = `${periodWidth}%`;
                    eventEl.style.marginLeft = '0';
                }
            } else { // event type 'event'
                const position = ((eventData.year - absoluteMinYear) / totalRange) * 100;
                eventEl.style.left = `${position}%`;
            }
        });
    }

    function handlePeriodMouseEnter() {
        const eventId = parseInt(this.dataset.eventId);
        const eventData = events[eventId];
        if (eventData && periodDescriptionBox && periodTitleBox && periodYearsBox && periodDescBox) {
            periodTitleBox.textContent = eventData.title;
            
            let startYearText = eventData.startYear < 0 ? `${-eventData.startYear} ${t('bc')}` : `${eventData.startYear} ${t('ad')}`;
            if (eventData.startYear === 0) startYearText = "";
            let endYearText = eventData.endYear < 0 ? `${-eventData.endYear} ${t('bc')}` : `${eventData.endYear} ${t('ad')}`;
            if (eventData.endYear === 0) endYearText = "";
            periodYearsBox.textContent = `${startYearText} ${t('until')} ${endYearText}`;
            
            periodDescBox.textContent = eventData.description || '';
            periodDescriptionBox.style.display = 'block';
            if (characterDescriptionPopup) characterDescriptionPopup.style.display = 'none'; // Esconde o popup de personagem/evento
        }
    }

    function handlePeriodMouseLeave() {
        if (periodDescriptionBox) {
            periodDescriptionBox.style.display = 'none';
        }
    }

    // FUNÇÃO CORRIGIDA: Função para ajustar largura da barra de personagem
    function adjustPersonBarWidth(eventEl) {
        const label = eventEl.querySelector('.person-label');
        const lifeSpan = eventEl.querySelector('.life-span');
        
        if (label) {
            // Obter a largura atual baseada no tempo (em porcentagem)
            const currentWidthPercent = parseFloat(eventEl.style.width) || 0;
            
            // Obter a largura do contêiner da timeline
            const timelineWidth = timeline.offsetWidth;
            
            // Obter a largura do texto do label em pixels
            const labelWidthPx = label.offsetWidth;
            
            // Converter a largura do label para porcentagem da timeline
            const labelWidthPercent = (labelWidthPx / timelineWidth) * 100;
            
            // Usar a maior largura entre a baseada no tempo e a necessária para o texto
            const finalWidthPercent = Math.max(currentWidthPercent, labelWidthPercent);
            
            // Aplicar a largura em porcentagem
            eventEl.style.width = `${finalWidthPercent}%`;
            
            // Garantir que o label e o lifeSpan ocupem 100% da largura
            label.style.width = '100%';
            if (lifeSpan) lifeSpan.style.width = '100%';
        }
    }

    // Função para posicionar corretamente as barras dos períodos alinhadas aos controles de busca
    function positionPeriodBars() {
        const timeline = document.querySelector('.timeline-horizontal');
        const bars = document.querySelectorAll('.period-top-bar');
        
        if (!timeline || bars.length === 0) return;
        
        function getAnchorTop() {
            const search = document.querySelector('.search-container');
            const icon = document.querySelector('.search-icon');
            const searchVisible = search && getComputedStyle(search).display !== 'none';
            const el = searchVisible ? search : icon;
            return el ? el.getBoundingClientRect().top : 20; // fallback
        }
        
        const timelineRect = timeline.getBoundingClientRect();
        const anchorTop = getAnchorTop();
        const base = anchorTop - timelineRect.top;
        
        bars.forEach(bar => {
            const row = parseFloat(getComputedStyle(bar).getPropertyValue('--period-row')) || 0;
            const rowHeight = 25; // Should match the rowHeight used in drag system
            // Ajustar para ficar uma linha mais para cima (padrão inicial)
            bar.style.top = `${base + (row * rowHeight) - rowHeight}px`;
        });
    }
    
    function doPeriodsOverlap(start1, end1, start2, end2) {
        const s1 = Math.min(start1, end1);
        const e1 = Math.max(start1, end1);
        const s2 = Math.min(start2, end2);
        const e2 = Math.max(start2, end2);
        return Math.max(s1, s2) < Math.min(e1, e2);
    }

    function createEventElement(eventData) {
        const eventId = events.indexOf(eventData).toString();

        if (eventData.type === 'period') {
            const periodEl = document.createElement('div');
            periodEl.className = 'event period-overlay';
            let colorRgba = applyAlpha(eventData.color, (eventData.opacity || 20) / 100);
            periodEl.style.setProperty('--period-color', colorRgba);
            periodEl.style.backgroundColor = colorRgba;
            const startPos = ((eventData.startYear - absoluteMinYear) / totalRange) * 100;
            const endPos = ((eventData.endYear - absoluteMinYear) / totalRange) * 100;
            const periodWidth = endPos - startPos;
            periodEl.style.left = `${startPos}%`;
            
            // Garantir largura mínima visível para períodos curtos
            if (periodWidth < 0.3) {
                periodEl.style.width = '10px'; // Largura mínima fixa para períodos muito curtos
                periodEl.style.marginLeft = '-5px'; // Centralizar o período
            } else {
                periodEl.style.width = `${periodWidth}%`;
            }
            
            const label = document.createElement('div');
            label.className = 'period-label';
            label.textContent = eventData.title;
            periodEl.appendChild(label);
            // O event-content para period-overlay é gerenciado pela caixa fixa period-description-box
            periodEl.dataset.eventId = eventId;
            periodEl.addEventListener('mouseenter', handlePeriodMouseEnter);
            periodEl.addEventListener('mouseleave', handlePeriodMouseLeave);
            periodEl.addEventListener('contextmenu', (e) => showContextMenu(e, periodEl));
            periodEl.setAttribute('role', 'button');
            periodEl.setAttribute('aria-label', `${t('period')}: ${eventData.title}`);
            periodEl.style.zIndex = '1';
            return periodEl;

        } else if (eventData.type === 'person') {
            const eventEl = document.createElement('div');
            eventEl.className = 'event person-event';
            if (eventData.lockedPosition) {
                eventEl.classList.add('locked');
                eventEl.dataset.locked = 'true';
            }
            let colorRgba = applyAlpha(eventData.color, (eventData.opacity || 100) / 100);
            eventEl.style.setProperty('--person-color', colorRgba);

            const startPos = ((eventData.birthYear - absoluteMinYear) / totalRange) * 100;
            const endPos = ((eventData.deathYear - absoluteMinYear) / totalRange) * 100;
            const widthPercentage = endPos - startPos;

            eventEl.style.left = `${startPos}%`;
            eventEl.style.width = `${widthPercentage}%`;

            const row = eventData.personRow;
            if (typeof row !== 'number') {
                eventEl.style.setProperty('--person-row', '0');
                eventEl.style.top = `calc(-24px - (0 * 24px))`;
            } else {
                eventEl.style.setProperty('--person-row', row.toString());
                eventEl.style.top = `calc(-24px - (${row} * 24px))`;
            }

            const lifeSpan = document.createElement('div');
            lifeSpan.className = 'life-span';
            if (eventData.impreciseBirth && eventData.impreciseDeath) lifeSpan.classList.add('imprecise-both');
            else if (eventData.impreciseBirth) lifeSpan.classList.add('imprecise-start');
            else if (eventData.impreciseDeath) lifeSpan.classList.add('imprecise-end');
            lifeSpan.style.background = colorRgba;

            let age;
            if (eventData.birthYear < 0 && eventData.deathYear > 0) {
                age = eventData.deathYear - eventData.birthYear - 2;
            } else {
                age = eventData.deathYear - eventData.birthYear;
            }
            
            const label = document.createElement('div');
            label.className = 'person-label';
            label.textContent = eventData.title;

            const content = document.createElement('div');
            content.className = 'event-content';
            
            let birthYearText = eventData.birthYear < 0 ? `${-eventData.birthYear} ${t('bc')}` : `${eventData.birthYear} ${t('ad')}`;
            if (eventData.birthYear === 0) birthYearText = "";
            let deathYearText = eventData.deathYear < 0 ? `${-eventData.deathYear} ${t('bc')}` : `${eventData.deathYear} ${t('ad')}`;
            if (eventData.deathYear === 0) deathYearText = "";

            // Adicionamos o ícone do cadeado no tooltip, mas somente se o personagem estiver travado
            const lockIconHtml = eventData.lockedPosition ? '<span class="lock-icon">🔒</span>' : '';
            
            content.innerHTML = `
                <h4>${sanitizeHtml(eventData.title)}</h4>
                <p>${eventData.impreciseBirth ? '(aprox.) ' : ''}${birthYearText} ${t('until')} ${eventData.impreciseDeath ? '(aprox.) ' : ''}${deathYearText}</p>
                <p><strong>${age} ${t('age_years')}</strong> ${lockIconHtml}</p>
            `;
            eventEl.appendChild(lifeSpan);
            eventEl.appendChild(label);
            eventEl.appendChild(content);
            eventEl.addEventListener('contextmenu', (e) => showContextMenu(e, eventEl));
            eventEl.dataset.eventId = eventId;
            eventEl.setAttribute('role', 'button');
            eventEl.setAttribute('aria-label', `${t('character')}: ${eventData.title}`);

            eventEl.addEventListener('mouseenter', () => {
                if (characterDescriptionPopup && characterPopupDescriptionText && eventData) {
                    characterPopupDescriptionText.textContent = eventData.description || ''; 
                    characterDescriptionPopup.style.display = 'block';
                    if (periodDescriptionBox) periodDescriptionBox.style.display = 'none'; 
                }
            });

            eventEl.addEventListener('mouseleave', () => {
                if (characterDescriptionPopup) {
                    characterDescriptionPopup.style.display = 'none';
                }
            });

            adjustPersonBarWidth(eventEl);
            return eventEl;

        } else { // Event Type 'event' (flag)
            const position = ((eventData.year - absoluteMinYear) / totalRange) * 100;
            const eventEl = document.createElement('div');
            eventEl.className = 'event event-flag';
            if (eventData.lockedPosition) {
                eventEl.classList.add('locked');
                eventEl.dataset.locked = 'true';
            }
            eventEl.style.zIndex = '10';
            eventEl.style.left = `${position}%`;
            
            // Aplicar posição vertical personalizada se existir
            if (eventData.flagVerticalPosition !== undefined) {
                eventEl.style.top = `${eventData.flagVerticalPosition}px`;
            }
            
            let colorRgba = applyAlpha(eventData.color || '#4676E0', (eventData.opacity||100)/100);
            eventEl.style.setProperty('--event-color', colorRgba);

            let maxPersonRowForFlagHeight = -1;
            window.events.forEach(p => {
                if (p.type === 'person' && typeof p.personRow === 'number') {
                    if (p.personRow > maxPersonRowForFlagHeight) {
                        maxPersonRowForFlagHeight = p.personRow;
                    }
                }
            });

            const baseHeight = 200 + ((maxPersonRowForFlagHeight + 1) * 24) + 10;
            const line = document.createElement('div');
            line.className = 'event-flag-line';
            line.style.height = `${baseHeight}px`;
            
            let yearText = eventData.year < 0 ? `${-eventData.year} ${t('bc')}` : `${eventData.year} ${t('ad')}`;
            if (eventData.year === 0) yearText = "";
            line.dataset.year = yearText;

            const content = document.createElement('div');
            content.className = 'event-content';
            
            const lockIconHtml = eventData.lockedPosition ? '<span class="lock-icon">🔒</span>' : '';
            
            content.innerHTML = `
                <h3>${yearText}</h3>
                <h4>${sanitizeHtml(eventData.title)}</h4>
                ${lockIconHtml ? `<p>${lockIconHtml}</p>` : ''}
            `;
            
            eventEl.appendChild(line);
            eventEl.appendChild(content); 
            eventEl.setAttribute('role', 'button');
            eventEl.setAttribute('aria-label', `${t('event')}: ${eventData.title} em ${yearText}`);

            eventEl.addEventListener('mouseenter', () => {
                if (characterDescriptionPopup && characterPopupDescriptionText && eventData) {
                    characterPopupDescriptionText.textContent = eventData.description || ''; 
                    characterDescriptionPopup.style.display = 'block';
                     if (periodDescriptionBox) periodDescriptionBox.style.display = 'none';
                }
            });

            eventEl.addEventListener('mouseleave', () => {
                if (characterDescriptionPopup) {
                    characterDescriptionPopup.style.display = 'none';
                }
            });

            eventEl.addEventListener('contextmenu', (e) => showContextMenu(e, eventEl));
            eventEl.dataset.eventId = eventId;
            return eventEl;
        }
    }

    function applyAlpha(hexOrRgb, alpha) {
        alpha = Math.max(0, Math.min(1, Math.round(alpha * 100) / 100));
        if (hexOrRgb.startsWith('#')) {
            let hex = hexOrRgb.replace('#', '');
            if (hex.length === 3) hex = hex.split('').map(x => x + x).join('');
            const num = parseInt(hex, 16);
            const r = (num >> 16) & 255;
            const g = (num >> 8) & 255;
            const b = num & 255;
            return `rgba(${r},${g},${b},${alpha})`;
        } else if (hexOrRgb.startsWith('rgb')) {
            let m = hexOrRgb.match(/[\d.]+/g);
            if (m && m.length >= 3) return `rgba(${m[0]},${m[1]},${m[2]},${alpha})`;
        }
        return hexOrRgb;
    }

    function setupOpacityInputs() {
        const eventOpacity = document.getElementById('event-opacity');
        const eventOpacityValue = document.getElementById('event-opacity-value');
        if (eventOpacity && eventOpacityValue) {
            eventOpacityValue.textContent = eventOpacity.value + '%';
            eventOpacity.addEventListener('input', () => eventOpacityValue.textContent = eventOpacity.value + '%' );
        }
        const personOpacity = document.getElementById('person-opacity');
        const personOpacityValue = document.getElementById('person-opacity-value');
        if (personOpacity && personOpacityValue) {
            personOpacityValue.textContent = personOpacity.value + '%';
            personOpacity.addEventListener('input', () => personOpacityValue.textContent = personOpacity.value + '%' );
        }
    }

    function setPersonForm() {
        const eventFields = document.querySelector('.event-fields');
        const personFields = document.querySelector('.person-fields');
        
        if (eventFields) eventFields.style.display = 'none';
        if (personFields) {
            personFields.innerHTML = `
                <label data-i18n="character_period">Personagem - Período do Personagem</label>
                <div class="form-row">
                  <div class="form-group autocomplete-container">
                    <label for="birth-year" data-i18n="start_date">Data Inicial:</label>
                    <input type="number" id="birth-year" required class="autocomplete-input">
                    <div class="autocomplete-suggestions"></div>
                  </div>
                  <div style="display: flex; align-items: center; padding: 0 10px;">
                    <span data-i18n="until">até</span>
                  </div>
                  <div class="form-group autocomplete-container">
                    <label for="death-year" data-i18n="end_date">Data Final:</label>
                    <input type="number" id="death-year" required class="autocomplete-input">
                    <div class="autocomplete-suggestions"></div>
                  </div>
                </div>
                <div class="form-row checkbox-container">
                  <div class="checkbox-wrapper">
                    <input type="checkbox" id="imprecise-birth">
                    <label for="imprecise-birth" data-i18n="approximate_start">Data inicial aproximada</label>
                  </div>
                  <div class="checkbox-wrapper">
                    <input type="checkbox" id="imprecise-death">
                    <label for="imprecise-death" data-i18n="approximate_end">Data final aproximada</label>
                  </div>
                </div>
                <label for="person-color" data-i18n="character_color">Cor do Personagem:</label>
                <input type="color" id="person-color" value="#4676E0">
                <label for="person-opacity" data-i18n="transparency">Transparência:</label>
                <input type="range" id="person-opacity" min="0" max="100" value="100" style="width: 120px;">
                <span id="person-opacity-value">100%</span>
            `;
            personFields.style.display = 'block';
        }
        applyTranslations(); // Aplicar traduções aos novos elementos
        setupOpacityInputs();
        setupAutoComplete();
    }

    function setEventForm() {
        const eventFields = document.querySelector('.event-fields');
        const personFields = document.querySelector('.person-fields');
        
        if (eventFields) {
            eventFields.innerHTML = `
                <label for="event-year" data-i18n="year_label">Ano (use - para A.C.):</label>
                <input type="number" id="event-year" required class="autocomplete-input">
                <div class="autocomplete-suggestions"></div>
                <label for="event-color" data-i18n="event_color">Cor do Evento:</label>
                <input type="color" id="event-color" value="#4676E0">
                <label for="event-opacity" data-i18n="transparency">Transparência:</label>
                <input type="range" id="event-opacity" min="0" max="100" value="100" style="width: 120px;">
                <span id="event-opacity-value">100%</span>
            `;
            eventFields.style.display = 'block';
        }
        if (personFields) personFields.style.display = 'none';
        applyTranslations(); // Aplicar traduções aos novos elementos
        setupOpacityInputs();
        setupAutoComplete();
    }

    function setPeriodForm() {
        const eventFields = document.querySelector('.event-fields');
        const personFields = document.querySelector('.person-fields');
        
        if (eventFields) {
            eventFields.innerHTML = `
                <div class="form-group">
                  <label data-i18n="period">Período:</label>
                  <div class="form-row">
                      <div class="form-group autocomplete-container">
                          <label for="period-start" data-i18n="start_date">Data Inicial:</label>
                          <input type="number" id="period-start" required class="autocomplete-input">
                          <div class="autocomplete-suggestions"></div>
                      </div>
                      <div style="display: flex; align-items: center; padding: 0 10px;">
                          <span data-i18n="until">até</span>
                      </div>
                      <div class="form-group autocomplete-container">
                          <label for="period-end" data-i18n="end_date">Data Final:</label>
                          <input type="number" id="period-end" required class="autocomplete-input">
                          <div class="autocomplete-suggestions"></div>
                      </div>
                  </div>
                  <small style="color: var(--text-color);">Obs.: Para A.C. usar sinal -</small>
                </div>
                <div class="form-group">
                  <label for="event-color" data-i18n="event_color">Cor do Período:</label>
                  <input type="color" id="event-color" value="#4676E0">
                  <label for="event-opacity" data-i18n="transparency">Transparência:</label>
                  <input type="range" id="event-opacity" min="0" max="100" value="20" style="width: 120px;">
                  <span id="event-opacity-value">20%</span>
                </div>
            `;
            eventFields.style.display = 'block';
        }
        if (personFields) personFields.style.display = 'none';
        applyTranslations(); // Aplicar traduções aos novos elementos
        setupOpacityInputs();
        setupAutoComplete();
    }

    // Configuração de auto completar para campos de data
    function setupAutoComplete() {
        const autocompleteInputs = document.querySelectorAll('.autocomplete-input');
        
        autocompleteInputs.forEach(input => {
            const suggestionsContainer = input.parentElement.querySelector('.autocomplete-suggestions');
            
            if (!suggestionsContainer) return;
            
            // Cria uma lista de anos já usados na linha do tempo
            let yearsUsed = [];
            
            events.forEach(event => {
                if (event.type === 'event') {
                    yearsUsed.push(event.year);
                } else if (event.type === 'person') {
                    yearsUsed.push(event.birthYear, event.deathYear);
                } else if (event.type === 'period') {
                    yearsUsed.push(event.startYear, event.endYear);
                }
            });
            
            // Remove duplicatas e ordena
            yearsUsed = [...new Set(yearsUsed)].sort((a, b) => a - b);
            
            // Adiciona alguns anos comuns para A.C. e D.C. caso não existam
            const commonYearsBC = [-3000, -2000, -1000, -500, -100, -50];
            const commonYearsAD = [0, 1, 500, 1000, 1500, 1800, 1900, 2000];
            
            yearsUsed = [...new Set([...yearsUsed, ...commonYearsBC, ...commonYearsAD])].sort((a, b) => a - b);
            
            // Função para mostrar sugestões baseadas no valor atual
            function showSuggestions() {
                const value = input.value.trim();
                
                // Se o campo estiver vazio, mostra alguns valores comuns
                let suggestions = value ? 
                    yearsUsed.filter(year => year.toString().includes(value)) : 
                    [-3000, -2000, -1000, -500, -100, 0, 1, 500, 1000, 1500, 1800, 1900, 2000];
                
                // Limitando a 5 sugestões
                suggestions = suggestions.slice(0, 5);
                
                if (suggestions.length > 0) {
                    let html = '';
                    suggestions.forEach(year => {
                        html += `<div class="autocomplete-suggestion" data-value="${year}">${formatYear(year)}</div>`;
                    });
                    
                    suggestionsContainer.innerHTML = html;
                    suggestionsContainer.classList.add('active');
                    
                    // Adiciona eventos de clique nas sugestões
                    const suggestionElements = suggestionsContainer.querySelectorAll('.autocomplete-suggestion');
                    suggestionElements.forEach(element => {
                        element.addEventListener('click', () => {
                            input.value = element.dataset.value;
                            suggestionsContainer.classList.remove('active');
                        });
                    });
                } else {
                    suggestionsContainer.classList.remove('active');
                }
            }
            
            // Eventos para mostrar e esconder sugestões
            input.addEventListener('focus', showSuggestions);
            input.addEventListener('input', showSuggestions);
            
            // Fechar sugestões ao clicar fora
            document.addEventListener('click', (e) => {
                if (!input.contains(e.target) && !suggestionsContainer.contains(e.target)) {
                    suggestionsContainer.classList.remove('active');
                }
            });
            
            // Navegação pelo teclado
            input.addEventListener('keydown', (e) => {
                const suggestions = suggestionsContainer.querySelectorAll('.autocomplete-suggestion');
                if (!suggestions.length) return;
                
                // Encontrar seleção atual
                let selected = suggestionsContainer.querySelector('.selected');
                let index = Array.from(suggestions).indexOf(selected);
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (selected) {
                        selected.classList.remove('selected');
                        index = (index + 1) % suggestions.length;
                    } else {
                        index = 0;
                    }
                    suggestions[index].classList.add('selected');
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (selected) {
                        selected.classList.remove('selected');
                        index = (index - 1 + suggestions.length) % suggestions.length;
                    } else {
                        index = suggestions.length - 1;
                    }
                    suggestions[index].classList.add('selected');
                } else if (e.key === 'Enter' && selected) {
                    e.preventDefault();
                    input.value = selected.dataset.value;
                    suggestionsContainer.classList.remove('active');
                } else if (e.key === 'Escape') {
                    suggestionsContainer.classList.remove('active');
                }
            });
        });
    }

    setupOpacityInputs();

    // Melhorar o manipulador de salvar com validação
    function defaultSaveHandler(e) {
        e.preventDefault();
        const isPersonForm = document.querySelector('.person-fields').style.display === 'block' && document.getElementById('birth-year');
        const isPeriodForm = document.getElementById('period-start') !== null && document.querySelector('.event-fields').style.display === 'block' && !document.getElementById('event-year');
        
        // Determina o tipo de formulário
        let type = 'event';
        if (isPersonForm) type = 'person';
        if (isPeriodForm) type = 'period';
        
        // Valida o formulário
        if (!validateForm(type)) return;
        
        if (isPersonForm) {
            const birthYear = parseInt(document.getElementById('birth-year').value);
            const deathYear = parseInt(document.getElementById('death-year').value);
            const title = document.getElementById('event-title').value;
            
            tempNewPersonData = {
                type: 'person', 
                birthYear, 
                deathYear, 
                title,
                description: document.getElementById('event-description').value || '',
                color: document.getElementById('person-color').value,
                impreciseBirth: document.getElementById('imprecise-birth').checked,
                impreciseDeath: document.getElementById('imprecise-death').checked,
                opacity: document.getElementById('person-opacity') ? parseInt(document.getElementById('person-opacity').value) : 100
            };
            
            // Fechar o formulário
            eventForm.classList.remove('active');
            
            // Mostrar diálogo de posicionamento
            positionDialog.style.display = 'block';
            
        } else if (isPeriodForm) {
            const startYear = parseInt(document.getElementById('period-start').value);
            const endYear = parseInt(document.getElementById('period-end').value);
            const title = document.getElementById('event-title').value;
            
            const newEventData = {
                type: 'period', 
                startYear, 
                endYear, 
                title,
                description: document.getElementById('event-description').value || '',
                color: document.getElementById('event-color').value,
                opacity: document.getElementById('event-opacity') ? parseInt(document.getElementById('event-opacity').value) : 20
            };
            
            events.push(newEventData);
            window.events = events;
            renderEvents();
            closeForm();
            showToast(t('period_added'));
            
            // Otimizaรงรฃo: Debouncing para salvamento automรกtico
            clearTimeout(window.autoSaveTimeout);
            window.autoSaveTimeout = setTimeout(() => {
                localStorage.setItem('timelineData', JSON.stringify({ events: window.events, zoom: currentZoom }));
            }, 500);
        } else {
            const year = parseInt(document.getElementById('event-year').value);
            const title = document.getElementById('event-title').value;
            
            const newEventData = {
                type: 'event', 
                year, 
                title,
                description: document.getElementById('event-description').value || '',
                color: document.getElementById('event-color').value,
                opacity: document.getElementById('event-opacity') ? parseInt(document.getElementById('event-opacity').value) : 100,
                flagVerticalPosition: -240, // Posição vertical padrão
                lockedPosition: false // Não travado por padrão
            };
            
            events.push(newEventData);
            window.events = events;
            renderEvents();
            closeForm();
            showToast(t('event_added'));
            
            // Otimizaรงรฃo: Debouncing para salvamento automรกtico
            clearTimeout(window.autoSaveTimeout);
            window.autoSaveTimeout = setTimeout(() => {
                localStorage.setItem('timelineData', JSON.stringify({ events: window.events, zoom: currentZoom }));
            }, 500);
        }
    }

    function closeForm() {
        eventForm.classList.remove('active');
        overlay.classList.remove('active');
        eventForm.reset();
        const formError = document.getElementById('form-error');
        if (formError) formError.style.display = 'none';
        
        if (saveBtn) saveBtn.onclick = defaultSaveHandler;
    }

    if (cancelBtn) cancelBtn.addEventListener('click', closeForm);
    
    if (overlay) {
        overlay.addEventListener('click', (e) => {
            // Fechamos o formulário ao clicar no overlay, mas não fechamos os modals
            if (eventForm.classList.contains('active')) {
                closeForm();
            }
            // Fechamos o context menu
            hideContextMenu();
            // Não fechamos nenhum modal se algum deles estiver ativo
            if ([statsModal, keyboardModal, tutorialModal, templatesModal].some(modal => modal && modal.classList.contains('active'))) {
                return;
            }
        });
    }
    
    const saveFileBtn = document.querySelector('.save-btn');
    if (saveFileBtn) saveFileBtn.addEventListener('click', saveToFile);

    function saveToFile() {
        // Prepara os dados para salvar incluindo eventos
        const dataToSave = {
            events: events,
            zoom: currentZoom
        };
        
        const data = JSON.stringify(dataToSave);
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'timelineData.json';
        a.click();
        URL.revokeObjectURL(url);
        showToast(t('timeline_saved'));
    }


    function exportToPDF() {
        // Cria um container especial para o PDF com design melhorado
        const pdfContainer = document.createElement('div');
        pdfContainer.className = 'pdf-container';
        
        // Cabeçalho com título
        const header = document.createElement('div');
        header.className = 'pdf-header';
        header.innerHTML = `
            <h1 class="pdf-title">${t('page_title')}</h1>
            <div class="pdf-subtitle">Gerado em ${new Date().toLocaleDateString()} às ${new Date().toLocaleTimeString()}</div>
        `;
        pdfContainer.appendChild(header);
        
        // Adiciona o clone da linha do tempo
        const timelineClone = document.createElement('div');
        timelineClone.className = 'pdf-timeline';
        
        // Gera um sumário dos eventos
        const summary = document.createElement('div');
        summary.style.marginBottom = '30px';
        
        let summaryContent = `<h2 style="color: #1565C0; margin-bottom: 15px;">Sumário dos Eventos</h2>`;
        summaryContent += '<div style="columns: 2; column-gap: 20px;">';
        
        // Organiza eventos cronologicamente
        const eventsSorted = [...events].sort((a, b) => {
            const timeA = a.type === 'event' ? a.year : a.type === 'person' ? a.birthYear : a.startYear;
            const timeB = b.type === 'event' ? b.year : b.type === 'person' ? b.birthYear : b.startYear;
            return timeA - timeB;
        });
        
        eventsSorted.forEach(event => {
            let timeText = '';
            let typeIcon = '';
            
            if (event.type === 'event') {
                timeText = formatYear(event.year);
                typeIcon = '<svg viewBox="0 0 24 24" width="16" height="16" style="margin-right: 5px; vertical-align: middle;"><path fill="currentColor" d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"></path></svg>';
            } else if (event.type === 'person') {
                timeText = `${formatYear(event.birthYear)} - ${formatYear(event.deathYear)}`;
                typeIcon = '<svg viewBox="0 0 24 24" width="16" height="16" style="margin-right: 5px; vertical-align: middle;"><path fill="currentColor" d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0-6c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm0 7c-2.67 0-8 1.34-8 4v3h16v-3c0-2.66-5.33-4-8-4z"></path></svg>';
            } else if (event.type === 'period') {
                timeText = `${formatYear(event.startYear)} - ${formatYear(event.endYear)}`;
                typeIcon = '<svg viewBox="0 0 24 24" width="16" height="16" style="margin-right: 5px; vertical-align: middle;"><path fill="currentColor" d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V9h14v10zm0-12H5V5h14v2zM7 11h5v5H7z"></path></svg>';
            }
            
            summaryContent += `
                <div style="margin-bottom: 10px; break-inside: avoid;">
                    <div style="font-weight: bold;">${typeIcon} ${sanitizeHtml(event.title)}</div>
                    <div style="font-size: 12px; color: #555;">${timeText}</div>
                </div>
            `;
        });
        
        summaryContent += '</div>';
        summary.innerHTML = summaryContent;
        pdfContainer.appendChild(summary);
        
        // Adiciona a timeline atual ao container
        const timelineActual = timelineContainer.cloneNode(true);
        timelineActual.style.height = '500px';
        timelineActual.style.position = 'relative';
        timelineActual.style.overflow = 'hidden';
        timelineActual.style.marginBottom = '30px';
        timelineActual.style.border = '1px solid #ddd';
        timelineActual.style.borderRadius = '8px';
        
        timelineClone.appendChild(timelineActual);
        pdfContainer.appendChild(timelineClone);
        
        // Adiciona metadados e rodapé
        const meta = document.createElement('div');
        meta.className = 'pdf-meta';
        meta.innerHTML = `
            <div>Total de eventos: ${events.filter(e => e.type === 'event').length}</div>
            <div>Total de personagens: ${events.filter(e => e.type === 'person').length}</div>
            <div>Total de períodos: ${events.filter(e => e.type === 'period').length}</div>
        `;
        pdfContainer.appendChild(meta);
        
        const watermark = document.createElement('div');
        watermark.className = 'pdf-watermark';
        watermark.textContent = `Criado com ${t('page_title')}`;
        pdfContainer.appendChild(watermark);
        
        // Configura opções do PDF
        const opt = {
            margin: [10, 10, 10, 10],
            filename: 'linha_do_tempo_historica.pdf',
            image: { type: 'jpeg', quality: 0.98 },
            html2canvas: { scale: 2 },
            jsPDF: { unit: 'mm', format: 'a4', orientation: 'landscape' }
        };
        
        showToast(t('generating_pdf'));
        if (window.html2pdf) {
            html2pdf().set(opt).from(pdfContainer).save().then(() => {
                showToast(t('pdf_generated'));
            }).catch(err => {
                console.error("Erro ao gerar PDF:", err);
                showToast("Erro ao gerar PDF", "error");
            });
        } else {
            showToast("Biblioteca de PDF não carregada", "error");
        }
    }

    function showContextMenu(e, eventEl) {
        e.preventDefault();
        e.stopPropagation();
        selectedEventElement = eventEl;
        const isInsideForm = eventForm.contains(e.target);
        const isActiveDropdown = document.querySelector('.action-buttons.active');
        const isInsideDropdown = isActiveDropdown && isActiveDropdown.querySelector('.dropdown-content').contains(e.target);
        if (isInsideForm || isInsideDropdown) {
            hideContextMenu();
            return;
        }
        
        // Verifica se é um personagem, flag de evento ou barra de período para mostrar a opção de travar/destravar
        const eventId = parseInt(eventEl.dataset.eventId);
        const eventData = events[eventId];
        const isPeriodBar = eventEl.classList.contains('period-top-bar');
        
        if (eventData && (eventData.type === 'person' || eventData.type === 'event' || eventData.type === 'period')) {
            if (contextToggleLock) {
                contextToggleLock.style.display = 'block';
                contextToggleLock.textContent = eventData.lockedPosition ? t('unlock_position') : t('lock_position');
            }
        } else {
            if (contextToggleLock) {
                contextToggleLock.style.display = 'none';
            }
        }
        
        contextMenu.style.left = e.pageX + 'px';
        contextMenu.style.top = e.pageY + 'px';
        contextMenu.classList.add('active');
    }

    function hideContextMenu() {
        contextMenu.classList.remove('active');
        selectedEventElement = null;
    }
    
    // Adicionar manipulador para opção de travar/destravar
    if (contextToggleLock) {
        contextToggleLock.addEventListener('click', function() {
            if (!selectedEventElement) return;
            
            const eventId = parseInt(selectedEventElement.dataset.eventId);
            const eventData = events[eventId];
            
            if (eventData && (eventData.type === 'person' || eventData.type === 'event' || eventData.type === 'period')) {
                // Inverte o estado de travamento
                eventData.lockedPosition = !eventData.lockedPosition;
                
                // Atualiza a interface
                if (eventData.lockedPosition) {
                    selectedEventElement.classList.add('locked');
                    selectedEventElement.dataset.locked = 'true';
                } else {
                    selectedEventElement.classList.remove('locked');
                    delete selectedEventElement.dataset.locked;
                }
                
                // Atualiza o conteúdo do evento para refletir a mudança
                const content = selectedEventElement.querySelector('.event-content');
                if (content) {
                    if (eventData.type === 'person') {
                        let birthYearText = eventData.birthYear < 0 ? `${-eventData.birthYear} ${t('bc')}` : `${eventData.birthYear} ${t('ad')}`;
                        if (eventData.birthYear === 0) birthYearText = "";
                        let deathYearText = eventData.deathYear < 0 ? `${-eventData.deathYear} ${t('bc')}` : `${eventData.deathYear} ${t('ad')}`;
                        if (eventData.deathYear === 0) deathYearText = "";
                        
                        let age;
                        if (eventData.birthYear < 0 && eventData.deathYear > 0) {
                            age = eventData.deathYear - eventData.birthYear - 2;
                        } else {
                            age = eventData.deathYear - eventData.birthYear;
                        }
                        
                        // Adicionar ou remover o ícone de cadeado baseado no estado de travamento
                        const lockIconHtml = eventData.lockedPosition ? '<span class="lock-icon">🔒</span>' : '';
                        
                        content.innerHTML = `
                            <h4>${sanitizeHtml(eventData.title)}</h4>
                            <p>${eventData.impreciseBirth ? '(aprox.) ' : ''}${birthYearText} ${t('until')} ${eventData.impreciseDeath ? '(aprox.) ' : ''}${deathYearText}</p>
                            <p><strong>${age} ${t('age_years')}</strong> ${lockIconHtml}</p>
                        `;
                    } else if (eventData.type === 'event') {
                        let yearText = eventData.year < 0 ? `${-eventData.year} ${t('bc')}` : `${eventData.year} ${t('ad')}`;
                        if (eventData.year === 0) yearText = "";
                        
                        const lockIconHtml = eventData.lockedPosition ? '<span class="lock-icon">🔒</span>' : '';
                        
                        content.innerHTML = `
                            <h3>${yearText}</h3>
                            <h4>${sanitizeHtml(eventData.title)}</h4>
                            ${lockIconHtml ? `<p>${lockIconHtml}</p>` : ''}
                        `;
                    } else if (eventData.type === 'period') {
                        let startYearText = eventData.startYear < 0 ? `${-eventData.startYear} ${t('bc')}` : `${eventData.startYear} ${t('ad')}`;
                        let endYearText = eventData.endYear < 0 ? `${-eventData.endYear} ${t('bc')}` : `${eventData.endYear} ${t('ad')}`;
                        if (eventData.startYear === 0) startYearText = "";
                        if (eventData.endYear === 0) endYearText = "";
                        
                        const lockIconHtml = eventData.lockedPosition ? '<span class="lock-icon">🔒</span>' : '';
                        
                        content.innerHTML = `
                            <div style="color: white; font-weight: bold; padding: 2px 5px; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">
                                ${sanitizeHtml(eventData.title)} 
                                ${lockIconHtml}
                                <span style="font-size: 12px; margin-left: 5px;">(${startYearText} - ${endYearText})</span>
                            </div>
                        `;
                    }
                }
                
                // Salva as alterações
                localStorage.setItem('timelineData', JSON.stringify({ events: window.events, zoom: currentZoom }));
                
                let entityType = '';
                let lockMessage = '';
                let unlockMessage = '';
                
                if (eventData.type === 'person') {
                    entityType = t('character');
                    lockMessage = t('character_locked');
                    unlockMessage = t('character_unlocked');
                } else if (eventData.type === 'event') {
                    entityType = 'Flag';
                    lockMessage = t('flag_locked');
                    unlockMessage = t('flag_unlocked');
                } else if (eventData.type === 'period') {
                    entityType = 'Período';
                    lockMessage = 'foi travado';
                    unlockMessage = 'foi destravado';
                }
                
                showToast(eventData.lockedPosition ? 
                    `${entityType} "${eventData.title}" ${lockMessage}` : 
                    `${entityType} "${eventData.title}" ${unlockMessage}`);
            }
            
            hideContextMenu();
        });
    }

    const editMenuItem = document.querySelector('.context-menu-item.edit');
    if (editMenuItem) {
        editMenuItem.addEventListener('click', function() {
            if (!selectedEventElement) return;
            const eventIndex = parseInt(selectedEventElement.dataset.eventId);
            const eventData = events[eventIndex];
            if (!eventData) return;

            if (eventData.type === 'period') {
                setPeriodForm();
                const periodStart = document.getElementById('period-start');
                const periodEnd = document.getElementById('period-end');
                const eventColor = document.getElementById('event-color');
                const eventOpacity = document.getElementById('event-opacity');
                const eventOpacityValue = document.getElementById('event-opacity-value');
                
                if (periodStart) periodStart.value = eventData.startYear;
                if (periodEnd) periodEnd.value = eventData.endYear;
                if (eventColor) eventColor.value = eventData.color || '#4676E0';
                if (eventOpacity) eventOpacity.value = eventData.opacity !== undefined ? eventData.opacity : 20;
                if (eventOpacityValue) eventOpacityValue.textContent = (eventData.opacity !== undefined ? eventData.opacity : 20) + '%';
            } else if (eventData.type === 'person') {
                setPersonForm();
                const birthYear = document.getElementById('birth-year');
                const deathYear = document.getElementById('death-year');
                const personColor = document.getElementById('person-color');
                const impreciseBirth = document.getElementById('imprecise-birth');
                const impreciseDeath = document.getElementById('imprecise-death');
                const personOpacity = document.getElementById('person-opacity');
                const personOpacityValue = document.getElementById('person-opacity-value');
                
                if (birthYear) birthYear.value = eventData.birthYear;
                if (deathYear) deathYear.value = eventData.deathYear;
                if (personColor) personColor.value = eventData.color || '#4676E0';
                if (impreciseBirth) impreciseBirth.checked = eventData.impreciseBirth || false;
                if (impreciseDeath) impreciseDeath.checked = eventData.impreciseDeath || false;
                if (personOpacity) {
                    personOpacity.value = eventData.opacity !== undefined ? eventData.opacity : 100;
                    if (personOpacityValue) personOpacityValue.textContent = (eventData.opacity !== undefined ? eventData.opacity : 100) + '%';
                }
            } else { // Evento tipo 'event' (bandeira)
                setEventForm();
                const eventYear = document.getElementById('event-year');
                const eventColor = document.getElementById('event-color');
                const eventOpacity = document.getElementById('event-opacity');
                const eventOpacityValue = document.getElementById('event-opacity-value');
                
                if (eventYear) eventYear.value = eventData.year;
                if (eventColor) eventColor.value = eventData.color || '#4676E0';
                if (eventOpacity) eventOpacity.value = eventData.opacity !== undefined ? eventData.opacity : 100;
                if (eventOpacityValue) eventOpacityValue.textContent = (eventData.opacity !== undefined ? eventData.opacity : 100) + '%';
            }
            
            const eventTitle = document.getElementById('event-title');
            const eventDescription = document.getElementById('event-description');
            if (eventTitle) eventTitle.value = eventData.title;
            if (eventDescription) eventDescription.value = eventData.description || '';
            
            eventForm.classList.add('active');
            overlay.classList.add('active');
            const formError = document.getElementById('form-error');
            if (formError) formError.style.display = 'none';

            if (saveBtn) {
                saveBtn.onclick = function(eClick) {
                    eClick.preventDefault();
                    
                    // Validação aprimorada
                    if (!validateForm(eventData.type)) return;
                    
                    let updatedEventData = { ...eventData };

                    if (eventData.type === 'person') {
                        const newBirthYear = parseInt(document.getElementById('birth-year').value);
                        const newDeathYear = parseInt(document.getElementById('death-year').value);
                        
                        updatedEventData = { ...updatedEventData,
                            birthYear: newBirthYear,
                            deathYear: newDeathYear,
                            title: document.getElementById('event-title').value,
                            description: document.getElementById('event-description').value,
                            color: document.getElementById('person-color').value,
                            impreciseBirth: document.getElementById('imprecise-birth').checked,
                            impreciseDeath: document.getElementById('imprecise-death').checked,
                            opacity: document.getElementById('person-opacity') ? parseInt(document.getElementById('person-opacity').value) : 100
                        };
                    } else if (eventData.type === 'period') {
                         const newStartYear = parseInt(document.getElementById('period-start').value);
                         const newEndYear = parseInt(document.getElementById('period-end').value);
                        
                        updatedEventData = { ...updatedEventData,
                            startYear: newStartYear,
                            endYear: newEndYear,
                            title: document.getElementById('event-title').value,
                            description: document.getElementById('event-description').value,
                            color: document.getElementById('event-color').value,
                            opacity: document.getElementById('event-opacity') ? parseInt(document.getElementById('event-opacity').value) : 20
                        };
                    } else {
                        updatedEventData = { ...updatedEventData,
                            year: parseInt(document.getElementById('event-year').value),
                            title: document.getElementById('event-title').value,
                            description: document.getElementById('event-description').value,
                            color: document.getElementById('event-color').value,
                            opacity: document.getElementById('event-opacity') ? parseInt(document.getElementById('event-opacity').value) : 100
                        };
                    }
                    events[eventIndex] = updatedEventData;
                    window.events = events;
                    renderEvents();
                    closeForm();
                    hideContextMenu();
                    showToast(t('event_updated'));
                    
                    // Salva automaticamente após editar
                    localStorage.setItem('timelineData', JSON.stringify({ events: window.events, zoom: currentZoom }));
                };
            }
        });
    }

    const deleteMenuItem = document.querySelector('.context-menu-item.delete');
    if (deleteMenuItem) {
        deleteMenuItem.addEventListener('click', () => {
            if (!selectedEventElement) return;
            const eventIndex = parseInt(selectedEventElement.dataset.eventId);
            if (confirm(t('confirm_delete'))) {
                events.splice(eventIndex, 1);
                window.events = events;
                renderEvents();
                hideContextMenu();
                showToast(t('event_removed'));
                
                // Salva automaticamente após remover
                localStorage.setItem('timelineData', JSON.stringify({ events: window.events, zoom: currentZoom }));
            } else {
                hideContextMenu();
            }
        });
    }


    document.addEventListener('click', (e) => {
      if (contextMenu && !contextMenu.contains(e.target) && selectedEventElement && !eventForm.contains(e.target)) {
          hideContextMenu();
      }
      const actionButtonsContainer = document.querySelector('.action-buttons');
      if (actionButtonsContainer && !actionButtonsContainer.contains(e.target) && actionButtonsContainer.classList.contains('active')) {
          actionButtonsContainer.classList.remove('active');
      }
    });
    if(contextMenu) contextMenu.addEventListener('click', (e) => e.stopPropagation());

    if (menuBtn) {
        menuBtn.addEventListener('click', function(e) {
            e.stopPropagation();
            document.querySelector('.action-buttons').classList.toggle('active');
        });
    }

    if (addPersonBtn) {
        addPersonBtn.addEventListener('click', () => {
            setPersonForm(); 
            if (eventForm) eventForm.reset();
            const eventTitle = document.getElementById('event-title');
            const eventDescription = document.getElementById('event-description');
            if (eventTitle) eventTitle.value = '';
            if (eventDescription) eventDescription.value = '';
            eventForm.classList.add('active'); 
            overlay.classList.add('active');
            if (saveBtn) saveBtn.onclick = defaultSaveHandler;
            const formError = document.getElementById('form-error');
            if (formError) formError.style.display = 'none';
        });
    }
    
    if (addEventBtn) {
        addEventBtn.addEventListener('click', () => {
            setEventForm(); 
            if (eventForm) eventForm.reset();
            const eventTitle = document.getElementById('event-title');
            const eventDescription = document.getElementById('event-description');
            if (eventTitle) eventTitle.value = '';
            if (eventDescription) eventDescription.value = '';
            eventForm.classList.add('active'); 
            overlay.classList.add('active');
            if (saveBtn) saveBtn.onclick = defaultSaveHandler;
            const formError = document.getElementById('form-error');
            if (formError) formError.style.display = 'none';
        });
    }
    
    if (addPeriodBtn) {
        addPeriodBtn.addEventListener('click', () => {
            setPeriodForm(); 
            if (eventForm) eventForm.reset();
            const eventTitle = document.getElementById('event-title');
            const eventDescription = document.getElementById('event-description');
            if (eventTitle) eventTitle.value = '';
            if (eventDescription) eventDescription.value = '';
            eventForm.classList.add('active'); 
            overlay.classList.add('active');
            if (saveBtn) saveBtn.onclick = defaultSaveHandler;
            const formError = document.getElementById('form-error');
            if (formError) formError.style.display = 'none';
        });
    }

    renderEvents();
    
    // Otimizaรงรฃo: Debouncing para resize event para melhor performance
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            positionPeriodBars();
            // Reposicionar outros elementos se necessรกrio
            const statsModal = document.getElementById('stats-modal');
            if (statsModal && statsModal.classList.contains('active') && typeof updateStatistics === 'function') {
                updateStatistics();
            }
        }, 150);
    });

    function centerTimelineOnLoad() {
        const zoomFactor = 1 + (currentZoom / 100) * 29;
        const baseWidth = 100;
        timeline.style.width = `${baseWidth * zoomFactor}%`;
        const centerYearPositionRatio = (4500 - absoluteMinYear) / totalRange;
        const timelinePhysicalWidth = timeline.offsetWidth;
        const centerScrollPosition = (timelinePhysicalWidth * centerYearPositionRatio) - (timelineContainer.offsetWidth / 2);
        if (timelineContainer) {
            timelineContainer.scrollLeft = centerScrollPosition > 0 ? centerScrollPosition : 0;
        }
    }
    setTimeout(centerTimelineOnLoad, 150);

    // SISTEMA DE MARCADORES SIMPLIFICADO E EFICIENTE
    function createDateMarkers() {
        const dateMarkersContainer = timeline.querySelector('.date-markers');
        if (!dateMarkersContainer) return;
        
        // Limpeza completa - remove todos os marcadores existentes
        dateMarkersContainer.innerHTML = '';
        const existingMarkers = timeline.querySelectorAll('.date-marker, .minor-tick');
        existingMarkers.forEach(marker => marker.remove());
        
        // Usando variáveis globais: absoluteMinYear, absoluteMaxYear, totalRange
        const timelineWidth = timeline.offsetWidth;
        
        // Fragmento para melhor performance
        const fragment = document.createDocumentFragment();
        
        // Calcular espaçamento mínimo necessário em anos
        // Para zoom 100%, reduzir drasticamente para que 10 anos caibam bem
        const minTextSpacingPx = currentZoom === 100 ? 60 : 70; // Espaço mínimo entre textos em pixels
        const minTextSpacingPercent = (minTextSpacingPx / timelineWidth) * 100;
        const minTextYearSpacing = (minTextSpacingPercent / 100) * totalRange;
        
        const minTickSpacingPx = currentZoom === 100 ? 6 : 15; // Espaço mínimo entre marcações em pixels
        const minTickSpacingPercent = (minTickSpacingPx / timelineWidth) * 100;
        const minTickYearSpacing = (minTickSpacingPercent / 100) * totalRange;
        
        // Determinar intervalos baseados no zoom
        let textStep, tickStep;
        
        // Lógica especial para zoom 100%
        if (currentZoom === 100) {
            // No zoom máximo, sempre forçar 10 anos independente do cálculo
            textStep = 10; // Textos de 10 em 10 anos
            tickStep = 1;  // Marcações de 1 em 1 ano
        } else {
            // Calcular step ideal para textos
            if (minTextYearSpacing <= 1) {
                textStep = 1;
            } else if (minTextYearSpacing <= 2) {
                textStep = 2;
            } else if (minTextYearSpacing <= 5) {
                textStep = 5;
            } else if (minTextYearSpacing <= 10) {
                textStep = 10;
            } else if (minTextYearSpacing <= 20) {
                textStep = 20;
            } else if (minTextYearSpacing <= 25) {
                textStep = 25;
            } else if (minTextYearSpacing <= 50) {
                textStep = 50;
            } else if (minTextYearSpacing <= 100) {
                textStep = 100;
            } else if (minTextYearSpacing <= 250) {
                textStep = 250;
            } else if (minTextYearSpacing <= 500) {
                textStep = 500;
            } else {
                textStep = 1000;
            }
            
            // Calcular step ideal para marcações visuais
            if (minTickYearSpacing <= 1) {
                tickStep = 1;
            } else if (minTickYearSpacing <= 2) {
                tickStep = 2;
            } else if (minTickYearSpacing <= 5) {
                tickStep = 5;
            } else if (minTickYearSpacing <= 10) {
                tickStep = 10;
            } else if (minTickYearSpacing <= 25) {
                tickStep = 25;
            } else if (minTickYearSpacing <= 50) {
                tickStep = 50;
            } else if (minTickYearSpacing <= 100) {
                tickStep = 100;
            } else if (minTickYearSpacing <= 250) {
                tickStep = 250;
            } else {
                tickStep = 500;
            }
        }
        
        // Garantir que tickStep seja menor ou igual ao textStep
        if (tickStep > textStep) {
            tickStep = textStep;
        }
        
        // Criar todas as marcações visuais
        for(let year = absoluteMinYear; year <= absoluteMaxYear; year += tickStep) {
            const marker = document.createElement('div');
            const position = ((year - absoluteMinYear) / totalRange) * 100;
            marker.style.left = `${position}%`;
            
            // Determinar se deve mostrar texto
            const shouldShowText = (year % textStep === 0);
            
            if (shouldShowText) {
                marker.className = 'date-marker';
                const span = document.createElement('span');
                
                // Tamanho da fonte baseado no zoom
                let fontSize = 11;
                if (currentZoom <= 20) fontSize = 10;
                else if (currentZoom <= 50) fontSize = 11;
                else if (currentZoom <= 80) fontSize = 12;
                else fontSize = 10; // Fonte menor para zoom alto
                
                span.style.fontSize = fontSize + 'px';
                
                let yearText = '';
                if (year < 0) {
                    yearText = `${-year} ${t('bc')}`;
                } else if (year > 0) {
                    yearText = `${year} ${t('ad')}`;
                } else {
                    // Ano 0 - não mostra nada
                    yearText = '';
                }
                
                // Apenas adiciona span se houver texto para mostrar
                if (yearText.trim() !== '') {
                    span.textContent = yearText;
                    marker.appendChild(span);
                }
            } else {
                // Apenas marcação visual
                marker.className = 'minor-tick';
            }
            
            fragment.appendChild(marker);
        }
        
        dateMarkersContainer.appendChild(fragment);
        
        // Criar linhas de grade vertical após criar marcadores
        createVerticalGridLines();
    }

    function renderEvents(skipReposition = false) {
        if (!skipReposition) {
            // Remove a propriedade personRow apenas para personagens não travados
            events.forEach(event => {
                if (event.type === 'person' && !event.lockedPosition) {
                    delete event.personRow;
                }
            });

            // Filtra apenas os personagens que não estão travados para calcular as posições
            const personEventsToAssignRows = events.filter(e => e.type === 'person' && !e.lockedPosition);

            personEventsToAssignRows.sort((a, b) => {
                if (a.birthYear !== b.birthYear) {
                    return b.birthYear - a.birthYear;
                }
                const indexA = window.events.indexOf(a);
                const indexB = window.events.indexOf(b);
                return indexA - indexB;
            });

            const occupiedRowsMap = [];
            
            // Primeiro, considere os personagens com posição travada
            events.filter(e => e.type === 'person' && e.lockedPosition).forEach(lockedPerson => {
                const row = lockedPerson.personRow !== undefined ? lockedPerson.personRow : 0;
                if (!occupiedRowsMap[row]) {
                    occupiedRowsMap[row] = [];
                }
                occupiedRowsMap[row].push(lockedPerson);
            });

            // Depois, atribua linhas para personagens não travados
            personEventsToAssignRows.forEach(currentPerson => {
                let assignedRow = -1;
                for (let r = 0; ; r++) {
                    if (!occupiedRowsMap[r]) {
                        occupiedRowsMap[r] = [];
                    }

                    let overlapsOnThisRow = false;
                    for (const pOnRow of occupiedRowsMap[r]) {
                        if (doPeriodsOverlap(currentPerson.birthYear, currentPerson.deathYear, pOnRow.birthYear, pOnRow.deathYear)) {
                            overlapsOnThisRow = true;
                            break;
                        }
                    }

                    if (!overlapsOnThisRow) {
                        currentPerson.personRow = r;
                        occupiedRowsMap[r].push(currentPerson);
                        assignedRow = r;
                        break;
                    }
                }
            });
        }

        // Limpar o timeline e configurar estrutura básica
        timeline.innerHTML = '<div class="background-grid" id="background-grid"></div><div class="timeline-line"></div><div class="date-markers"></div>';

        // Usar DocumentFragment para otimizar a renderização
        const fragment = document.createDocumentFragment();

        // Renderiza períodos primeiro (camada inferior)
        const periodRows = [];
        events.filter(e => e.type === 'period').forEach(eventData => {
            fragment.appendChild(createEventElement(eventData));
            
            // Determinar linha para evitar sobreposição
            const startPos = ((eventData.startYear - absoluteMinYear) / totalRange) * 100;
            const endPos = ((eventData.endYear - absoluteMinYear) / totalRange) * 100;
            
            let assignedRow = eventData.periodRow !== undefined ? eventData.periodRow : 0;
            
            if (eventData.periodRow === undefined) {
                // Encontrar primeira linha disponível
                for (let r = 0; r < 50; r++) {
                    let hasOverlap = false;
                    for (let otherEvent of events.filter(e => e.type === 'period' && e !== eventData)) {
                        if (otherEvent.periodRow === r && doPeriodsOverlap(eventData.startYear, eventData.endYear, otherEvent.startYear, otherEvent.endYear)) {
                            hasOverlap = true;
                            break;
                        }
                    }
                    if (!hasOverlap) {
                        assignedRow = r;
                        eventData.periodRow = r;
                        break;
                    }
                }
            }
            
            // Criar barra identificadora no topo para este período
            const topBar = document.createElement('div');
            topBar.className = 'period-top-bar';
            if (eventData.lockedPosition) {
                topBar.classList.add('locked');
                topBar.dataset.locked = 'true';
            }
            
            const colorRgba = applyAlpha(eventData.color, (eventData.opacity || 20) / 100);
            topBar.style.setProperty('--period-color', colorRgba);
            topBar.style.setProperty('--period-row', assignedRow.toString());
            
            const periodWidth = endPos - startPos;
            topBar.style.left = `${startPos}%`;
            if (periodWidth < 0.3) {
                topBar.style.width = '10px';
                topBar.style.marginLeft = '-5px';
            } else {
                topBar.style.width = `${periodWidth}%`;
            }
            
            // Adicionar event listeners para arrastar, menu de contexto e hover
            const eventId = events.indexOf(eventData).toString();
            topBar.dataset.eventId = eventId;
            topBar.addEventListener('contextmenu', (e) => showContextMenu(e, topBar));
            topBar.addEventListener('mouseenter', handlePeriodMouseEnter);
            topBar.addEventListener('mouseleave', handlePeriodMouseLeave);
            
            fragment.appendChild(topBar);
        });
        
        // Posicionar barras dos períodos corretamente alinhadas aos controles de busca
        timeline.appendChild(fragment);
        positionPeriodBars();
        
        // Continuar com fragment vazio para o resto
        const restFragment = document.createDocumentFragment();
        
        // Depois renderiza personagens
        events.filter(e => e.type === 'person').forEach(eventData => {
            restFragment.appendChild(createEventElement(eventData));
        });
        
        // Por último, renderiza eventos (camada superior)
        events.filter(e => e.type === 'event').forEach(eventData => {
            restFragment.appendChild(createEventElement(eventData));
        });

        timeline.appendChild(restFragment);

        // Otimizaรงรฃo: Usar delegaรงรฃo de eventos para melhor performance
        if (!timeline.periodEventsDelegated) {
            timeline.addEventListener('mouseenter', function(e) {
                if (e.target.classList.contains('period-overlay')) {
                    handlePeriodMouseEnter.call(e.target, e);
                }
            }, true);
            timeline.addEventListener('mouseleave', function(e) {
                if (e.target.classList.contains('period-overlay')) {
                    handlePeriodMouseLeave.call(e.target, e);
                }
            }, true);
            timeline.periodEventsDelegated = true;
        }

        createDateMarkers();
        document.querySelectorAll('.person-event').forEach(eventEl => adjustPersonBarWidth(eventEl));
        localStorage.setItem('timelineData', JSON.stringify({ events: window.events, zoom: currentZoom }));
        enableVerticalDragging();
        enableFlagVerticalDragging();
        enablePeriodBarDragging();
    }

    // ZOOM SLIDER REFORMULADO COM CENTRALIZAÇÃO
    if (zoomSlider) {
        zoomSlider.addEventListener('input', function(e) {
            // Capturar posição atual do scroll antes do zoom
            const scrollLeft = timelineContainer.scrollLeft;
            const containerWidth = timelineContainer.offsetWidth;
            const currentTimelineWidth = timeline.offsetWidth;
            
            // Calcular a posição relativa atual (0 a 1)
            const currentScrollRatio = currentTimelineWidth > 0 ? scrollLeft / (currentTimelineWidth - containerWidth) : 0;
            
            window.currentZoom = currentZoom = parseInt(e.target.value);
            if (zoomLabel) zoomLabel.textContent = currentZoom + '%';
            
            // Novo sistema de zoom baseado em espaçamento progressivo
            const zoomFactor = 1 + (currentZoom / 100) * 29; // De 1x a 20x
            const baseWidth = 100;
            timeline.style.width = `${baseWidth * zoomFactor}%`;
            
            // Reposicionar eventos com novo sistema
            updateEventsPosition();
            
            // Recriar marcadores de data com espaçamento inteligente
            createDateMarkers();
            
            // Manter a posição centralizada após o zoom
            setTimeout(() => {
                const newTimelineWidth = timeline.offsetWidth;
                const newScrollLeft = Math.max(0, currentScrollRatio * (newTimelineWidth - containerWidth));
                timelineContainer.scrollLeft = newScrollLeft;
            }, 50);
            
            // Atualizar período overlays
            // Event listeners jรก estรฃo delegados no container principal
        });
    }

    // Touch zoom com centralização
    let initialPinchDistance = null;
    let initialZoomValue = null;
    if (timelineContainer) {
        timelineContainer.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                e.preventDefault();
                initialPinchDistance = getPinchDistance(e.touches);
                initialZoomValue = currentZoom;
            }
        }, { passive: false });
        
        timelineContainer.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2 && initialPinchDistance !== null) {
                e.preventDefault();
                
                // Capturar posição antes do zoom
                const scrollLeft = timelineContainer.scrollLeft;
                const containerWidth = timelineContainer.offsetWidth;
                const currentTimelineWidth = timeline.offsetWidth;
                const currentScrollRatio = currentTimelineWidth > 0 ? scrollLeft / (currentTimelineWidth - containerWidth) : 0;
                
                const currentDistance = getPinchDistance(e.touches);
                const pinchScale = currentDistance / initialPinchDistance;
                let newZoom = initialZoomValue + (pinchScale - 1) * 50;
                newZoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, newZoom));
                
                if (zoomSlider) zoomSlider.value = newZoom;
                window.currentZoom = currentZoom = newZoom;
                if (zoomLabel) zoomLabel.textContent = Math.round(newZoom) + '%';
                
                const zoomFactor = 1 + (currentZoom / 100) * 29;
                const baseWidth = 100;
                timeline.style.width = `${baseWidth * zoomFactor}%`;
                
                updateEventsPosition();
                createDateMarkers();
                
                // Manter centralização
                setTimeout(() => {
                    const newTimelineWidth = timeline.offsetWidth;
                    const newScrollLeft = Math.max(0, currentScrollRatio * (newTimelineWidth - containerWidth));
                    timelineContainer.scrollLeft = newScrollLeft;
                }, 10);
            }
        }, { passive: false });
        
        timelineContainer.addEventListener('touchend', (e) => {
            if (e.touches.length < 2) {
                initialPinchDistance = null;
                initialZoomValue = null;
            }
        });
    }
    
    function getPinchDistance(touches) {
        return Math.hypot(touches[0].pageX - touches[1].pageX, touches[0].pageY - touches[1].pageY);
    }

    function enableVerticalDragging() {
        if (window.verticalDragMouseMoveListener) {
            document.removeEventListener('mousemove', window.verticalDragMouseMoveListener);
        }
        if (window.verticalDragMouseUpListener) {
             document.removeEventListener('mouseup', window.verticalDragMouseUpListener);
        }

        const personEvents = document.querySelectorAll('.person-event');
        const rowHeight = 24;

        personEvents.forEach(el => {
            if (el.dataset.verticalDragInitialized === 'true') return;

            el.onmousedown = (e) => {
                if (e.button !== 0 || e.target.closest('.event-content')) return;
                
                // Verifica se o personagem está travado
                const isLocked = el.classList.contains('locked');
                if (isLocked) return; // Se estiver travado, não permite arrastar

                if (document.querySelector('.person-event[data-is-being-dragged="true"]') || 
                    document.querySelector('.event-flag[data-is-being-dragged="true"]')) return;

                e.preventDefault();
                e.stopPropagation();

                el.dataset.isBeingDragged = 'true';
                el.dataset.startY = e.clientY.toString();
                const computedTop = window.getComputedStyle(el).top;
                el.dataset.startTop = parseFloat(computedTop).toString();
                el.style.transition = 'none';
                document.body.style.cursor = 'grabbing';
                el.style.zIndex = '10000'; 
            };
            el.dataset.verticalDragInitialized = 'true';
        });

        window.verticalDragMouseMoveListener = (e) => {
            const draggedEl = document.querySelector('.person-event[data-is-being-dragged="true"]');
            if (!draggedEl) return;

            const startY = parseFloat(draggedEl.dataset.startY);
            const startTop = parseFloat(draggedEl.dataset.startTop);
            const deltaY = e.clientY - startY;
            draggedEl.style.top = `${startTop + deltaY}px`;
        };

        window.verticalDragMouseUpListener = (e) => {
            const draggedEl = document.querySelector('.person-event[data-is-being-dragged="true"]');
            if (!draggedEl) return;

            draggedEl.style.transition = 'top 0.3s ease';
            document.body.style.cursor = 'default';
            
            const finalTopPixels = parseFloat(draggedEl.style.top) || 0;
            let newCalculatedRow = Math.round((-finalTopPixels - rowHeight) / rowHeight);
            newCalculatedRow = Math.max(0, newCalculatedRow);

            const eventId = parseInt(draggedEl.dataset.eventId);
            const eventData = window.events[eventId];
            let finalRowToSet = newCalculatedRow;

            if (eventData) {
                let overlap = false;
                for (const otherEvent of window.events) {
                    if (otherEvent.type === 'person' && otherEvent !== eventData && otherEvent.personRow === newCalculatedRow) {
                        if (doPeriodsOverlap(eventData.birthYear, eventData.deathYear, otherEvent.birthYear, otherEvent.deathYear)) {
                            overlap = true;
                            break;
                        }
                    }
                }

                if (overlap) {
                    finalRowToSet = eventData.personRow !== undefined ? eventData.personRow : 0;
                } else {
                    eventData.personRow = newCalculatedRow;
                }
            } else {
                finalRowToSet = newCalculatedRow;
            }

            draggedEl.style.setProperty('--person-row', finalRowToSet.toString());
            draggedEl.style.top = `calc(-${rowHeight}px - (${finalRowToSet} * ${rowHeight}px))`;
            draggedEl.style.zIndex = getComputedStyle(draggedEl).getPropertyValue('--person-event-zindex') || '5';


            if (eventData) {
                 localStorage.setItem('timelineData', JSON.stringify({ events: window.events, zoom: window.currentZoom }));
            }

            delete draggedEl.dataset.isBeingDragged;
            delete draggedEl.dataset.startY;
            delete draggedEl.dataset.startTop;

        };

        document.addEventListener('mousemove', window.verticalDragMouseMoveListener);
        document.addEventListener('mouseup', window.verticalDragMouseUpListener);
    }

    // Nova função para arrastar flags verticalmente
    function enableFlagVerticalDragging() {
        if (window.flagVerticalDragMouseMoveListener) {
            document.removeEventListener('mousemove', window.flagVerticalDragMouseMoveListener);
        }
        if (window.flagVerticalDragMouseUpListener) {
            document.removeEventListener('mouseup', window.flagVerticalDragMouseUpListener);
        }

        const eventFlags = document.querySelectorAll('.event-flag');

        eventFlags.forEach(el => {
            if (el.dataset.flagVerticalDragInitialized === 'true') return;

            el.onmousedown = (e) => {
                if (e.button !== 0 || e.target.closest('.event-content')) return;
                
                // Verifica se a flag está travada
                const isLocked = el.classList.contains('locked');
                if (isLocked) return; // Se estiver travada, não permite arrastar

                if (document.querySelector('.person-event[data-is-being-dragged="true"]') || 
                    document.querySelector('.event-flag[data-is-being-dragged="true"]')) return;

                e.preventDefault();
                e.stopPropagation();

                el.dataset.isBeingDragged = 'true';
                el.dataset.startY = e.clientY.toString();
                const computedTop = window.getComputedStyle(el).top;
                el.dataset.startTop = parseFloat(computedTop).toString();
                el.style.transition = 'none';
                document.body.style.cursor = 'grabbing';
                el.style.zIndex = '10000'; 
            };
            el.dataset.flagVerticalDragInitialized = 'true';
        });

        window.flagVerticalDragMouseMoveListener = (e) => {
            const draggedEl = document.querySelector('.event-flag[data-is-being-dragged="true"]');
            if (!draggedEl) return;

            const startY = parseFloat(draggedEl.dataset.startY);
            const startTop = parseFloat(draggedEl.dataset.startTop);
            const deltaY = e.clientY - startY;
            const newTop = startTop + deltaY;
            
            // Limitar o movimento vertical da flag (entre -500px e -50px por exemplo)
            const limitedTop = Math.max(-500, Math.min(-50, newTop));
            draggedEl.style.top = `${limitedTop}px`;
        };

        window.flagVerticalDragMouseUpListener = (e) => {
            const draggedEl = document.querySelector('.event-flag[data-is-being-dragged="true"]');
            if (!draggedEl) return;

            draggedEl.style.transition = 'top 0.3s ease';
            document.body.style.cursor = 'default';
            draggedEl.style.zIndex = '10';
            
            const finalTopPixels = parseFloat(draggedEl.style.top) || -240;
            
            const eventId = parseInt(draggedEl.dataset.eventId);
            const eventData = window.events[eventId];

            if (eventData && eventData.type === 'event') {
                // Salvar a nova posição vertical
                eventData.flagVerticalPosition = finalTopPixels;
                localStorage.setItem('timelineData', JSON.stringify({ events: window.events, zoom: window.currentZoom }));
            }

            delete draggedEl.dataset.isBeingDragged;
            delete draggedEl.dataset.startY;
            delete draggedEl.dataset.startTop;
        };

        document.addEventListener('mousemove', window.flagVerticalDragMouseMoveListener);
        document.addEventListener('mouseup', window.flagVerticalDragMouseUpListener);
    }
    
    // Nova função para arrastar barras de período verticalmente
    function enablePeriodBarDragging() {
        if (window.periodBarDragMouseMoveListener) {
            document.removeEventListener('mousemove', window.periodBarDragMouseMoveListener);
        }
        if (window.periodBarDragMouseUpListener) {
            document.removeEventListener('mouseup', window.periodBarDragMouseUpListener);
        }

        // Global reference to the currently dragged element
        let currentDraggedPeriodBar = null;
        
        const periodBars = document.querySelectorAll('.period-top-bar');
        const rowHeight = 25;

        periodBars.forEach(el => {
            if (el.dataset.periodBarDragInitialized === 'true') return;

            el.onmousedown = (e) => {
                if (e.button !== 0) return;
                
                // Verifica se a barra está travada
                const isLocked = el.classList.contains('locked');
                if (isLocked) return;

                // Check if another element is already being dragged
                if (currentDraggedPeriodBar) return;

                e.preventDefault();
                e.stopPropagation();

                // Set global reference to this element
                currentDraggedPeriodBar = el;

                // Não marcar como arrastando ainda - só preparar para drag
                el.dataset.startY = e.clientY.toString();
                const computedTop = parseFloat(window.getComputedStyle(el).top);
                el.dataset.startTop = computedTop.toString();
                el.dataset.originalTop = computedTop.toString(); // Guardar posição original
                el.dataset.dragStarted = 'false';
                document.body.style.cursor = 'grabbing';
            };
            el.dataset.periodBarDragInitialized = 'true';
        });

        window.periodBarDragMouseMoveListener = (e) => {
            const draggedEl = currentDraggedPeriodBar;
            if (!draggedEl || !draggedEl.dataset.startY) return;

            const startY = parseFloat(draggedEl.dataset.startY);
            const originalTop = parseFloat(draggedEl.dataset.originalTop);
            const deltaY = e.clientY - startY;
            
            // Só começar a arrastar se moveu pelo menos 8px (evitar movimento acidental)
            if (Math.abs(deltaY) < 8 && draggedEl.dataset.dragStarted !== 'true') {
                return;
            }
            
            // Marcar que o drag realmente começou
            if (draggedEl.dataset.dragStarted !== 'true') {
                draggedEl.dataset.isBeingDragged = 'true';
                draggedEl.dataset.dragStarted = 'true';
                draggedEl.style.transition = 'none';
                draggedEl.style.zIndex = '10000';
            }
            
            let newTop = originalTop + deltaY;
            
            // Limitar movimento: não pode subir além da posição atual, pode descer até 5 linhas
            const maxDownOffset = 5 * rowHeight; // 5 linhas para baixo
            const minTop = originalTop; // Não pode subir além da posição original (que já está uma linha acima)
            const maxTop = originalTop + maxDownOffset; // Pode descer até 5 linhas da posição original
            
            newTop = Math.max(minTop, Math.min(maxTop, newTop));
            
            draggedEl.style.top = `${newTop}px`;
        };

        window.periodBarDragMouseUpListener = (e) => {
            const draggedEl = currentDraggedPeriodBar;
            if (!draggedEl || !draggedEl.dataset.startY) return;
            
            const wasDragging = draggedEl.dataset.dragStarted === 'true';
            document.body.style.cursor = 'default';
            
            // Se não houve arraste real, não fazer nada (foi só um clique)
            if (!wasDragging) {
                // Limpar dados de drag
                delete draggedEl.dataset.startY;
                delete draggedEl.dataset.startTop;
                delete draggedEl.dataset.originalTop;
                delete draggedEl.dataset.dragStarted;
                // Clear global reference
                currentDraggedPeriodBar = null;
                return;
            }
            
            draggedEl.style.transition = 'top 0.3s ease';
            draggedEl.style.zIndex = '10';
            
            const finalTopPixels = parseFloat(draggedEl.style.top);
            const originalTop = parseFloat(draggedEl.dataset.originalTop);
            
            // Calcular qual linha baseado no deslocamento da posição original
            const deltaFromOriginal = finalTopPixels - originalTop;
            const newRow = Math.round(deltaFromOriginal / rowHeight);
            
            // Limitar: não pode subir (row 0 é o mínimo), pode descer até 5 linhas
            const clampedRow = Math.max(0, Math.min(5, newRow));
            
            const eventId = parseInt(draggedEl.dataset.eventId);
            if (!isNaN(eventId) && events[eventId]) {
                events[eventId].periodRow = clampedRow;
                draggedEl.style.setProperty('--period-row', clampedRow.toString());
                localStorage.setItem('timelineData', JSON.stringify({ events: window.events, zoom: window.currentZoom }));
            }
            
            // Limpar dados de drag
            delete draggedEl.dataset.isBeingDragged;
            delete draggedEl.dataset.startY;
            delete draggedEl.dataset.startTop;
            delete draggedEl.dataset.originalTop;
            delete draggedEl.dataset.dragStarted;
            
            // Clear global reference
            currentDraggedPeriodBar = null;
            
            // Reposicionar usando a função correta
            setTimeout(() => positionPeriodBars(), 100);
        };

        document.addEventListener('mousemove', window.periodBarDragMouseMoveListener);
        document.addEventListener('mouseup', window.periodBarDragMouseUpListener);
    }
    
    enableVerticalDragging();
    
    setupSearchAutocomplete();
    
    // Atalhos de teclado
    document.addEventListener('keydown', function(e) {
        // Evita executar atalhos quando estiver em um campo de texto
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
                // Alt + E: Adicionar evento
        if (e.altKey && e.key === 'e') {
            e.preventDefault();
            if (addEventBtn) addEventBtn.click();
        }
        
        // Alt + P: Adicionar personagem
        if (e.altKey && e.key === 'p') {
            e.preventDefault();
            if (addPersonBtn) addPersonBtn.click();
        }
        
        // Alt + T: Adicionar período
        if (e.altKey && e.key === 't') {
            e.preventDefault();
            if (addPeriodBtn) addPeriodBtn.click();
        }
        
        // Ctrl + S: Salvar
        if (e.ctrlKey && e.key === 's') {
            e.preventDefault();
            saveToFile();
        }
        
        // Ctrl + O: Abrir/Carregar
        if (e.ctrlKey && e.key === 'o') {
            e.preventDefault();
            const loadBtn = document.querySelector('.load-btn');
            if (loadBtn) loadBtn.click();
        }
        
        // Ctrl + I: Exportar para PNG
        if (e.ctrlKey && e.key === 'i') {
            e.preventDefault();
            exportToPNG();
        }
        
        // Ctrl + P: Exportar para PDF
        if (e.ctrlKey && e.key === 'p') {
            e.preventDefault();
            exportToPDF();
        }
        
        // Alt + D: Alternar modo escuro
        if (e.altKey && e.key === 'd') {
            e.preventDefault();
            if (darkModeItem) darkModeItem.click();
        }
        
        // F1: Ajuda
        if (e.key === 'F1') {
            e.preventDefault();
            if (helpBtn) helpBtn.click();
        }
        
        // Teclas + e -: Zoom com centralização
        if (e.key === '+' || e.key === '=') {
            e.preventDefault();
            const scrollLeft = timelineContainer.scrollLeft;
            const containerWidth = timelineContainer.offsetWidth;
            const currentTimelineWidth = timeline.offsetWidth;
            const currentScrollRatio = currentTimelineWidth > 0 ? scrollLeft / (currentTimelineWidth - containerWidth) : 0;
            
            const newZoom = Math.min(MAX_ZOOM, currentZoom + 5);
            if (zoomSlider) {
                zoomSlider.value = newZoom;
                window.currentZoom = currentZoom = newZoom;
                if (zoomLabel) zoomLabel.textContent = newZoom + '%';
                
                const zoomFactor = 1 + (currentZoom / 100) * 29;
                const baseWidth = 100;
                timeline.style.width = `${baseWidth * zoomFactor}%`;
                
                updateEventsPosition();
                createDateMarkers();
                
                setTimeout(() => {
                    const newTimelineWidth = timeline.offsetWidth;
                    const newScrollLeft = Math.max(0, currentScrollRatio * (newTimelineWidth - containerWidth));
                    timelineContainer.scrollLeft = newScrollLeft;
                }, 50);
            }
        }
        
        if (e.key === '-' || e.key === '_') {
            e.preventDefault();
            const scrollLeft = timelineContainer.scrollLeft;
            const containerWidth = timelineContainer.offsetWidth;
            const currentTimelineWidth = timeline.offsetWidth;
            const currentScrollRatio = currentTimelineWidth > 0 ? scrollLeft / (currentTimelineWidth - containerWidth) : 0;
            
            const newZoom = Math.max(MIN_ZOOM, currentZoom - 5);
            if (zoomSlider) {
                zoomSlider.value = newZoom;
                window.currentZoom = currentZoom = newZoom;
                if (zoomLabel) zoomLabel.textContent = newZoom + '%';
                
                const zoomFactor = 1 + (currentZoom / 100) * 29;
                const baseWidth = 100;
                timeline.style.width = `${baseWidth * zoomFactor}%`;
                
                updateEventsPosition();
                createDateMarkers();
                
                setTimeout(() => {
                    const newTimelineWidth = timeline.offsetWidth;
                    const newScrollLeft = Math.max(0, currentScrollRatio * (newTimelineWidth - containerWidth));
                    timelineContainer.scrollLeft = newScrollLeft;
                }, 50);
            }
        }
        
        // Setas para navegação
        if (e.key === 'ArrowLeft') {
            e.preventDefault();
            if (timelineContainer) {
                timelineContainer.scrollBy({ left: -100, behavior: 'smooth' });
            }
        }
        
        if (e.key === 'ArrowRight') {
            e.preventDefault();
            if (timelineContainer) {
                timelineContainer.scrollBy({ left: 100, behavior: 'smooth' });
            }
        }
    });
    
    
    function exportToPNG() {
        if (!window.html2canvas) {
            showToast("Biblioteca html2canvas não carregada", "error");
            return;
        }
        
        const target = document.createElement('div');
        target.className = 'pdf-container';
        document.body.appendChild(target);
        
        // Adiciona cabeçalho com título
        const header = document.createElement('div');
        header.className = 'pdf-header';
        header.innerHTML = `
            <h1 class="pdf-title">${t('page_title')}</h1>
            <div class="pdf-subtitle">Gerado em ${new Date().toLocaleDateString()} às ${new Date().toLocaleTimeString()}</div>
        `;
        target.appendChild(header);
        
        // Clone a linha do tempo
        const timelineClone = timelineContainer.cloneNode(true);
        timelineClone.style.position = 'relative';
        timelineClone.style.height = '500px';
        timelineClone.style.width = '100%';
        timelineClone.style.overflow = 'hidden';
        timelineClone.style.border = '1px solid #ddd';
        timelineClone.style.borderRadius = '8px';
        timelineClone.style.marginBottom = '20px';
        
        target.appendChild(timelineClone);
        
        // Rodapé com informações
        const footer = document.createElement('div');
        footer.style.textAlign = 'right';
        footer.style.margin = '10px 0';
        footer.style.fontSize = '12px';
        footer.style.color = '#777';
        footer.innerHTML = `Criado com ${t('page_title')} • Total de eventos: ${events.length}`;
        target.appendChild(footer);
        
        const popupsToHide = [
            document.getElementById('character-description-popup'),
            document.getElementById('period-description-box')
        ];              
                const originalDisplayStyles = popupsToHide.map(p => p ? p.style.display : '');
        popupsToHide.forEach(p => { if (p) p.style.display = 'none'; });
        
        showToast(t('generating_image'));
        
        html2canvas(target, {
          scale: 2,
          useCORS: true,
          backgroundColor: '#ffffff'
        }).then(canvas => {
          const link = document.createElement('a');
          link.download = 'linha_do_tempo.png';
          link.href = canvas.toDataURL('image/png');
          link.click();
          showToast(t('image_generated'));
          document.body.removeChild(target);
        }).catch(err => {
          console.error("Erro ao capturar imagem com html2canvas:", err);
          showToast("Erro ao capturar imagem: " + err.message, "error");
          document.body.removeChild(target);
        }).finally(() => {
            popupsToHide.forEach((p, index) => { if (p) p.style.display = originalDisplayStyles[index]; });
        });
    }
    
    // Configuração para estatísticas
    function updateStatistics() {
        // Contagens básicas
        const totalEvents = events.filter(e => e.type === 'event').length;
        const totalPersons = events.filter(e => e.type === 'person').length;
        const totalPeriods = events.filter(e => e.type === 'period').length;
        
        const totalEventsEl = document.getElementById('total-events');
        const totalPersonsEl = document.getElementById('total-persons');
        const totalPeriodsEl = document.getElementById('total-periods');
        
        if (totalEventsEl) totalEventsEl.textContent = totalEvents;
        if (totalPersonsEl) totalPersonsEl.textContent = totalPersons;
        if (totalPeriodsEl) totalPeriodsEl.textContent = totalPeriods;
        
        // Encontrar ano mais antigo e mais recente
        let allYears = [];
        
        events.forEach(event => {
            if (event.type === 'event') {
                allYears.push(event.year);
            } else if (event.type === 'person') {
                allYears.push(event.birthYear, event.deathYear);
            } else if (event.type === 'period') {
                allYears.push(event.startYear, event.endYear);
            }
        });
        
        if (allYears.length > 0) {
            const earliestYear = Math.min(...allYears);
            const latestYear = Math.max(...allYears);
            
            const earliestYearEl = document.getElementById('earliest-year');
            const latestYearEl = document.getElementById('latest-year');
            
            if (earliestYearEl) earliestYearEl.textContent = formatYear(earliestYear);
            if (latestYearEl) latestYearEl.textContent = formatYear(latestYear);
        }
        
        // Criando resumo por séculos
        const centuryContent = document.getElementById('century-content');
        if (centuryContent) {
            centuryContent.innerHTML = '';
            
            // Função auxiliar para obter o número do século
            function getCentury(year) {
                if (year < 0) {
                    return Math.floor(-year / 100) + 1 + `º século ${t('bc')}`;
                } else {
                    return Math.floor((year - 1) / 100) + 1 + `º século ${t('ad')}`;
                }
            }
            
            // Agrupar eventos por século
            const eventsByCentury = {};
            
            events.forEach(event => {
                let year;
                if (event.type === 'event') {
                    year = event.year;
                    const century = getCentury(year);
                    if (!eventsByCentury[century]) {
                        eventsByCentury[century] = { count: 0, events: [] };
                    }
                    eventsByCentury[century].count++;
                    eventsByCentury[century].events.push(event);
                } else if (event.type === 'person') {
                    // Considerar o nascimento da pessoa como ano principal
                    year = event.birthYear;
                    const century = getCentury(year);
                    if (!eventsByCentury[century]) {
                        eventsByCentury[century] = { count: 0, events: [] };
                    }
                    eventsByCentury[century].count++;
                    eventsByCentury[century].events.push(event);
                } else if (event.type === 'period') {
                    // Considerar o início do período como ano principal
                    year = event.startYear;
                    const century = getCentury(year);
                    if (!eventsByCentury[century]) {
                        eventsByCentury[century] = { count: 0, events: [] };
                    }
                    eventsByCentury[century].count++;
                    eventsByCentury[century].events.push(event);
                }
            });
            
            // Ordenar séculos
            const sortedCenturies = Object.keys(eventsByCentury).sort((a, b) => {
                const aIsAC = a.includes(t('bc'));
                const bIsAC = b.includes(t('bc'));
                
                if (aIsAC && !bIsAC) return -1;
                if (!aIsAC && bIsAC) return 1;
                
                const aNum = parseInt(a.match(/\d+/)[0]);
                const bNum = parseInt(b.match(/\d+/)[0]);
                
                if (aIsAC && bIsAC) return bNum - aNum; // Ordem decrescente para A.C.
                return aNum - bNum; // Ordem crescente para D.C.
            });
            
            // Criar cards de século no novo formato
            sortedCenturies.forEach(century => {
                const centuryData = eventsByCentury[century];
                
                // Pegar até 5 eventos principais deste século
                const highlights = centuryData.events
                    .sort((a, b) => {
                        // Ordenar por tipo (evento > pessoa > período) e depois por ano
                        if (a.type !== b.type) {
                            if (a.type === 'event') return -1;
                            if (b.type === 'event') return 1;
                            if (a.type === 'person') return -1;
                            if (b.type === 'person') return 1;
                        }
                        
                        const aYear = a.type === 'event' ? a.year : a.type === 'person' ? a.birthYear : a.startYear;
                        const bYear = b.type === 'event' ? b.year : b.type === 'person' ? b.birthYear : b.startYear;
                        
                        return aYear - bYear;
                    })
                    .slice(0, 5);
                
                const card = document.createElement('div');
                card.className = 'century-card';
                
                // Cabeçalho do card
                const cardHeader = document.createElement('div');
                cardHeader.className = 'century-card-header';
                cardHeader.innerHTML = `
                    <div class="century-card-title">${century}</div>
                    <div class="century-card-count">${centuryData.count} evento(s)</div>
                `;
                
                // Conteúdo do card
                const cardContent = document.createElement('div');
                cardContent.className = 'century-card-content';
                
                if (highlights.length > 0) {
                    highlights.forEach(event => {
                        const year = event.type === 'event' ? event.year : 
                                  event.type === 'person' ? event.birthYear : 
                                  event.startYear;
                                  
                        // Adicionar ícone apropriado para cada tipo de evento
                        let typeIcon = '';
                        if (event.type === 'event') {
                            typeIcon = '<svg viewBox="0 0 24 24" width="16" height="16" style="margin-right: 5px; vertical-align: middle;"><path fill="currentColor" d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"></path></svg>';
                        } else if (event.type === 'person') {
                            typeIcon = '<svg viewBox="0 0 24 24" width="16" height="16" style="margin-right: 5px; vertical-align: middle;"><path fill="currentColor" d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0-6c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm0 7c-2.67 0-8 1.34-8 4v3h16v-3c0-2.66-5.33-4-8-4z"></path></svg>';
                        } else if (event.type === 'period') {
                            typeIcon = '<svg viewBox="0 0 24 24" width="16" height="16" style="margin-right: 5px; vertical-align: middle;"><path fill="currentColor" d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V9h14v10zm0-12H5V5h14v2zM7 11h5v5H7z"></path></svg>';
                        }
                        
                        const eventItem = document.createElement('div');
                        eventItem.className = 'century-event-item';
                        eventItem.innerHTML = `
                            <div class="century-event-year">${formatYear(year)}</div>
                            <div class="century-event-title">${typeIcon}${sanitizeHtml(event.title)}</div>
                        `;
                        
                        cardContent.appendChild(eventItem);
                    });
                } else {
                    cardContent.innerHTML = '<div style="font-style: italic; opacity: 0.7;">Sem eventos significativos</div>';
                }
                
                card.appendChild(cardHeader);
                card.appendChild(cardContent);
                centuryContent.appendChild(card);
            });
            
            // Se não houver eventos em nenhum século
            if (sortedCenturies.length === 0) {
                const emptyCard = document.createElement('div');
                emptyCard.className = 'century-card';
                emptyCard.innerHTML = `
                    <div class="century-card-header">
                        <div class="century-card-title">Sem dados</div>
                        <div class="century-card-count">0</div>
                    </div>
                    <div class="century-card-content">
                        <div style="font-style: italic; opacity: 0.7;">Nenhum evento registrado</div>
                    </div>
                `;
                centuryContent.appendChild(emptyCard);
            }
        }
    }
    
    // Criar linhas de grade vertical
    function createVerticalGridLines() {
        // Obter o grid e limpar conteúdo anterior
        const grid = document.getElementById('background-grid');
        if (!grid) return;
        grid.innerHTML = '';
        
        // Verificar se as linhas verticais devem ser mostradas
        const showVerticalLines = document.body.classList.contains('show-vertical-lines');
        if (!showVerticalLines) return;
        
        // Obter todas as marcações de data
        const dateMarkers = document.querySelectorAll('.date-marker');
        const minorTicks = document.querySelectorAll('.minor-tick');
        
        // Criar linhas para marcadores principais
        dateMarkers.forEach(marker => {
            const left = marker.style.left;
            if (!left) return;
            
            const line = document.createElement('div');
            line.className = 'vertical-grid-line';
            line.style.left = left;
            grid.appendChild(line);
        });
        
        // Criar linhas para marcadores menores (mais finas ou com opacidade menor)
        minorTicks.forEach(tick => {
            const left = tick.style.left;
            if (!left) return;
            
            const line = document.createElement('div');
            line.className = 'vertical-grid-line';
            line.style.left = left;
            line.style.opacity = '0.5'; // Menos visível que as linhas principais
            grid.appendChild(line);
        });
    }
});

</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

</body></html>